"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-commands";
exports.ids = ["vendor-chunks/prosemirror-commands"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/prosemirror-commands/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: () => (/* binding */ autoJoin),\n/* harmony export */   baseKeymap: () => (/* binding */ baseKeymap),\n/* harmony export */   chainCommands: () => (/* binding */ chainCommands),\n/* harmony export */   createParagraphNear: () => (/* binding */ createParagraphNear),\n/* harmony export */   deleteSelection: () => (/* binding */ deleteSelection),\n/* harmony export */   exitCode: () => (/* binding */ exitCode),\n/* harmony export */   joinBackward: () => (/* binding */ joinBackward),\n/* harmony export */   joinDown: () => (/* binding */ joinDown),\n/* harmony export */   joinForward: () => (/* binding */ joinForward),\n/* harmony export */   joinTextblockBackward: () => (/* binding */ joinTextblockBackward),\n/* harmony export */   joinTextblockForward: () => (/* binding */ joinTextblockForward),\n/* harmony export */   joinUp: () => (/* binding */ joinUp),\n/* harmony export */   lift: () => (/* binding */ lift),\n/* harmony export */   liftEmptyBlock: () => (/* binding */ liftEmptyBlock),\n/* harmony export */   macBaseKeymap: () => (/* binding */ macBaseKeymap),\n/* harmony export */   newlineInCode: () => (/* binding */ newlineInCode),\n/* harmony export */   pcBaseKeymap: () => (/* binding */ pcBaseKeymap),\n/* harmony export */   selectAll: () => (/* binding */ selectAll),\n/* harmony export */   selectNodeBackward: () => (/* binding */ selectNodeBackward),\n/* harmony export */   selectNodeForward: () => (/* binding */ selectNodeForward),\n/* harmony export */   selectParentNode: () => (/* binding */ selectParentNode),\n/* harmony export */   selectTextblockEnd: () => (/* binding */ selectTextblockEnd),\n/* harmony export */   selectTextblockStart: () => (/* binding */ selectTextblockStart),\n/* harmony export */   setBlockType: () => (/* binding */ setBlockType),\n/* harmony export */   splitBlock: () => (/* binding */ splitBlock),\n/* harmony export */   splitBlockAs: () => (/* binding */ splitBlockAs),\n/* harmony export */   splitBlockKeepMarks: () => (/* binding */ splitBlockKeepMarks),\n/* harmony export */   toggleMark: () => (/* binding */ toggleMark),\n/* harmony export */   wrapIn: () => (/* binding */ wrapIn)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n\n\n\n/**\nDelete the selection, if there is one.\n*/ const deleteSelection = (state, dispatch)=>{\n    if (state.selection.empty) return false;\n    if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView());\n    return true;\n};\nfunction atBlockStart(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state) : $cursor.parentOffset > 0)) return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and at the start of a textblock, try to\nreduce the distance between that block and the one before itâ€”if\nthere's a block directly before it that can be joined, join them.\nIf not, try to move the selected block closer to the next one in\nthe document structure by lifting it out of its parent or moving it\ninto a parent of the previous block. Will use the view for accurate\n(bidi-aware) start-of-textblock detection if given.\n*/ const joinBackward = (state, dispatch, view)=>{\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor) return false;\n    let $cut = findCutBefore($cursor);\n    // If there is no node before this, try to lift\n    if (!$cut) {\n        let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n        if (target == null) return false;\n        if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    let before = $cut.nodeBefore;\n    // Apply the joining algorithm\n    if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch)) return true;\n    // If the node below has no content and the node above is\n    // selectable, delete the node below and select the one above.\n    if ($cursor.parent.content.size == 0 && (textblockAt(before, \"end\") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(before))) {\n        let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n            if (dispatch) {\n                let tr = state.tr.step(delStep);\n                tr.setSelection(textblockAt(before, \"end\") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    // If the node before is an atom, delete it\n    if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch) dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nA more limited form of [`joinBackward`]($commands.joinBackward)\nthat only tries to join the current textblock to the one before\nit, if the cursor is at the start of a textblock.\n*/ const joinTextblockBackward = (state, dispatch, view)=>{\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor) return false;\n    let $cut = findCutBefore($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\n/**\nA more limited form of [`joinForward`]($commands.joinForward)\nthat only tries to join the current textblock to the one after\nit, if the cursor is at the end of a textblock.\n*/ const joinTextblockForward = (state, dispatch, view)=>{\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor) return false;\n    let $cut = findCutAfter($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\nfunction joinTextblocksAround(state, $cut, dispatch) {\n    let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;\n    for(; !beforeText.isTextblock; beforePos--){\n        if (beforeText.type.spec.isolating) return false;\n        let child = beforeText.lastChild;\n        if (!child) return false;\n        beforeText = child;\n    }\n    let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;\n    for(; !afterText.isTextblock; afterPos++){\n        if (afterText.type.spec.isolating) return false;\n        let child = afterText.firstChild;\n        if (!child) return false;\n        afterText = child;\n    }\n    let step = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, beforePos, afterPos, prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n    if (!step || step.from != beforePos || step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep && step.slice.size >= afterPos - beforePos) return false;\n    if (dispatch) {\n        let tr = state.tr.step(step);\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, beforePos));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n}\nfunction textblockAt(node, side, only = false) {\n    for(let scan = node; scan; scan = side == \"start\" ? scan.firstChild : scan.lastChild){\n        if (scan.isTextblock) return true;\n        if (only && scan.childCount != 1) return false;\n    }\n    return false;\n}\n/**\nWhen the selection is empty and at the start of a textblock, select\nthe node before that textblock, if possible. This is intended to be\nbound to keys like backspace, after\n[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting\ncommands, as a fall-back behavior when the schema doesn't allow\ndeletion at the selected point.\n*/ const selectNodeBackward = (state, dispatch, view)=>{\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty) return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0) return false;\n        $cut = findCutBefore($head);\n    }\n    let node = $cut && $cut.nodeBefore;\n    if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) return false;\n    if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n    return true;\n};\nfunction findCutBefore($pos) {\n    if (!$pos.parent.type.spec.isolating) for(let i = $pos.depth - 1; i >= 0; i--){\n        if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1));\n        if ($pos.node(i).type.spec.isolating) break;\n    }\n    return null;\n}\nfunction atBlockEnd(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state) : $cursor.parentOffset < $cursor.parent.content.size)) return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and the cursor is at the end of a\ntextblock, try to reduce or remove the boundary between that block\nand the one after it, either by joining them or by moving the other\nblock closer to this one in the tree structure. Will use the view\nfor accurate start-of-textblock detection if given.\n*/ const joinForward = (state, dispatch, view)=>{\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor) return false;\n    let $cut = findCutAfter($cursor);\n    // If there is no node after this, there's nothing to do\n    if (!$cut) return false;\n    let after = $cut.nodeAfter;\n    // Try the joining algorithm\n    if (deleteBarrier(state, $cut, dispatch)) return true;\n    // If the node above has no content and the node below is\n    // selectable, delete the node above and select the one below.\n    if ($cursor.parent.content.size == 0 && (textblockAt(after, \"start\") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(after))) {\n        let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n            if (dispatch) {\n                let tr = state.tr.step(delStep);\n                tr.setSelection(textblockAt(after, \"start\") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    // If the next node is an atom, delete it\n    if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch) dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nWhen the selection is empty and at the end of a textblock, select\nthe node coming after that textblock, if possible. This is intended\nto be bound to keys like delete, after\n[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting\ncommands, to provide a fall-back behavior when the schema doesn't\nallow deletion at the selected point.\n*/ const selectNodeForward = (state, dispatch, view)=>{\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty) return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size) return false;\n        $cut = findCutAfter($head);\n    }\n    let node = $cut && $cut.nodeAfter;\n    if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) return false;\n    if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n    return true;\n};\nfunction findCutAfter($pos) {\n    if (!$pos.parent.type.spec.isolating) for(let i = $pos.depth - 1; i >= 0; i--){\n        let parent = $pos.node(i);\n        if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1));\n        if (parent.type.spec.isolating) break;\n    }\n    return null;\n}\n/**\nJoin the selected block or, if there is a text selection, the\nclosest ancestor block of the selection that can be joined, with\nthe sibling above it.\n*/ const joinUp = (state, dispatch)=>{\n    let sel = state.selection, nodeSel = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection, point;\n    if (nodeSel) {\n        if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.from)) return false;\n        point = sel.from;\n    } else {\n        point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.from, -1);\n        if (point == null) return false;\n    }\n    if (dispatch) {\n        let tr = state.tr.join(point);\n        if (nodeSel) tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nJoin the selected block, or the closest ancestor of the selection\nthat can be joined, with the sibling after it.\n*/ const joinDown = (state, dispatch)=>{\n    let sel = state.selection, point;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.to)) return false;\n        point = sel.to;\n    } else {\n        point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.to, 1);\n        if (point == null) return false;\n    }\n    if (dispatch) dispatch(state.tr.join(point).scrollIntoView());\n    return true;\n};\n/**\nLift the selected block, or the closest ancestor block of the\nselection that can be lifted, out of its parent node.\n*/ const lift = (state, dispatch)=>{\n    let { $from, $to } = state.selection;\n    let range = $from.blockRange($to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null) return false;\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nIf the selection is in a node whose type has a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, replace the\nselection with a newline character.\n*/ const newlineInCode = (state, dispatch)=>{\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;\n    if (dispatch) dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n    return true;\n};\nfunction defaultBlockAt(match) {\n    for(let i = 0; i < match.edgeCount; i++){\n        let { type } = match.edge(i);\n        if (type.isTextblock && !type.hasRequiredAttrs()) return type;\n    }\n    return null;\n}\n/**\nWhen the selection is in a node with a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a\ndefault block after the code block, and move the cursor there.\n*/ const exitCode = (state, dispatch)=>{\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;\n    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));\n    if (!type || !above.canReplaceWith(after, after, type)) return false;\n    if (dispatch) {\n        let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(tr.doc.resolve(pos), 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf a block node is selected, create an empty paragraph before (if\nit is its parent's first child) or after it.\n*/ const createParagraphNear = (state, dispatch)=>{\n    let sel = state.selection, { $from, $to } = sel;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false;\n    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n    if (!type || !type.isTextblock) return false;\n    if (dispatch) {\n        let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n        let tr = state.tr.insert(side, type.createAndFill());\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, side + 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf the cursor is in an empty textblock that can be lifted, lift the\nblock.\n*/ const liftEmptyBlock = (state, dispatch)=>{\n    let { $cursor } = state.selection;\n    if (!$cursor || $cursor.parent.content.size) return false;\n    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n        let before = $cursor.before();\n        if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, before)) {\n            if (dispatch) dispatch(state.tr.split(before).scrollIntoView());\n            return true;\n        }\n    }\n    let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null) return false;\n    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nCreate a variant of [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock) that uses\na custom function to determine the type of the newly split off block.\n*/ function splitBlockAs(splitNode) {\n    return (state, dispatch)=>{\n        let { $from, $to } = state.selection;\n        if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && state.selection.node.isBlock) {\n            if (!$from.parentOffset || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, $from.pos)) return false;\n            if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView());\n            return true;\n        }\n        if (!$from.parent.isBlock) return false;\n        if (dispatch) {\n            let atEnd = $to.parentOffset == $to.parent.content.size;\n            let tr = state.tr;\n            if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection || state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection) tr.deleteSelection();\n            let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n            let splitType = splitNode && splitNode($to.parent, atEnd);\n            let types = splitType ? [\n                splitType\n            ] : atEnd && deflt ? [\n                {\n                    type: deflt\n                }\n            ] : undefined;\n            let can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\n            if (!types && !can && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [\n                {\n                    type: deflt\n                }\n            ] : undefined)) {\n                if (deflt) types = [\n                    {\n                        type: deflt\n                    }\n                ];\n                can = true;\n            }\n            if (can) {\n                tr.split(tr.mapping.map($from.pos), 1, types);\n                if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {\n                    let first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first);\n                    if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n                }\n            }\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    };\n}\n/**\nSplit the parent block of the selection. If the selection is a text\nselection, also delete its content.\n*/ const splitBlock = splitBlockAs();\n/**\nActs like [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock), but without\nresetting the set of active marks at the cursor.\n*/ const splitBlockKeepMarks = (state, dispatch)=>{\n    return splitBlock(state, dispatch && ((tr)=>{\n        let marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n        if (marks) tr.ensureMarks(marks);\n        dispatch(tr);\n    }));\n};\n/**\nMove the selection to the node wrapping the current selection, if\nany. (Will not select the document node.)\n*/ const selectParentNode = (state, dispatch)=>{\n    let { $from, to } = state.selection, pos;\n    let same = $from.sharedDepth(to);\n    if (same == 0) return false;\n    pos = $from.before(same);\n    if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, pos)));\n    return true;\n};\n/**\nSelect the whole document.\n*/ const selectAll = (state, dispatch)=>{\n    if (dispatch) dispatch(state.tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection(state.doc)));\n    return true;\n};\nfunction joinMaybeClear(state, $pos, dispatch) {\n    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();\n    if (!before || !after || !before.type.compatibleContent(after.type)) return false;\n    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n        if (dispatch) dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n        return true;\n    }\n    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, $pos.pos))) return false;\n    if (dispatch) dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());\n    return true;\n}\nfunction deleteBarrier(state, $cut, dispatch) {\n    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;\n    if (before.type.spec.isolating || after.type.spec.isolating) return false;\n    if (joinMaybeClear(state, $cut, dispatch)) return true;\n    let canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n    if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {\n        if (dispatch) {\n            let end = $cut.pos + after.nodeSize, wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n            for(let i = conn.length - 1; i >= 0; i--)wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(conn[i].create(null, wrap));\n            wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(before.copy(wrap));\n            let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(wrap, 1, 0), conn.length, true));\n            let joinAt = end + 2 * conn.length;\n            if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinAt)) tr.join(joinAt);\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    }\n    let selAfter = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($cut, 1);\n    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target != null && target >= $cut.depth) {\n        if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n        let at = before, wrap = [];\n        for(;;){\n            wrap.push(at);\n            if (at.isTextblock) break;\n            at = at.lastChild;\n        }\n        let afterText = after, afterDepth = 1;\n        for(; !afterText.isTextblock; afterText = afterText.firstChild)afterDepth++;\n        if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n            if (dispatch) {\n                let end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n                for(let i = wrap.length - 1; i >= 0; i--)end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(wrap[i].copy(end));\n                let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(end, wrap.length, 0), 0, true));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction selectTextblockSide(side) {\n    return function(state, dispatch) {\n        let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;\n        let depth = $pos.depth;\n        while($pos.node(depth).isInline){\n            if (!depth) return false;\n            depth--;\n        }\n        if (!$pos.node(depth).isTextblock) return false;\n        if (dispatch) dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n        return true;\n    };\n}\n/**\nMoves the cursor to the start of current text block.\n*/ const selectTextblockStart = selectTextblockSide(-1);\n/**\nMoves the cursor to the end of current text block.\n*/ const selectTextblockEnd = selectTextblockSide(1);\n// Parameterized commands\n/**\nWrap the selection in a node of the given type with the given\nattributes.\n*/ function wrapIn(nodeType, attrs = null) {\n    return function(state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(range, nodeType, attrs);\n        if (!wrapping) return false;\n        if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n        return true;\n    };\n}\n/**\nReturns a command that tries to set the selected textblocks to the\ngiven node type with the given attributes.\n*/ function setBlockType(nodeType, attrs = null) {\n    return function(state, dispatch) {\n        let applicable = false;\n        for(let i = 0; i < state.selection.ranges.length && !applicable; i++){\n            let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n            state.doc.nodesBetween(from, to, (node, pos)=>{\n                if (applicable) return false;\n                if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return;\n                if (node.type == nodeType) {\n                    applicable = true;\n                } else {\n                    let $pos = state.doc.resolve(pos), index = $pos.index();\n                    applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n                }\n            });\n        }\n        if (!applicable) return false;\n        if (dispatch) {\n            let tr = state.tr;\n            for(let i = 0; i < state.selection.ranges.length; i++){\n                let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n                tr.setBlockType(from, to, nodeType, attrs);\n            }\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    };\n}\nfunction markApplies(doc, ranges, type) {\n    for(let i = 0; i < ranges.length; i++){\n        let { $from, $to } = ranges[i];\n        let can = $from.depth == 0 ? doc.inlineContent && doc.type.allowsMarkType(type) : false;\n        doc.nodesBetween($from.pos, $to.pos, (node)=>{\n            if (can) return false;\n            can = node.inlineContent && node.type.allowsMarkType(type);\n        });\n        if (can) return true;\n    }\n    return false;\n}\n/**\nCreate a command function that toggles the given mark with the\ngiven attributes. Will return `false` when the current selection\ndoesn't support that mark. This will remove the mark if any marks\nof that type exist in the selection, or add it otherwise. If the\nselection is empty, this applies to the [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks) instead of a range of the\ndocument.\n*/ function toggleMark(markType, attrs = null) {\n    return function(state, dispatch) {\n        let { empty, $cursor, ranges } = state.selection;\n        if (empty && !$cursor || !markApplies(state.doc, ranges, markType)) return false;\n        if (dispatch) {\n            if ($cursor) {\n                if (markType.isInSet(state.storedMarks || $cursor.marks())) dispatch(state.tr.removeStoredMark(markType));\n                else dispatch(state.tr.addStoredMark(markType.create(attrs)));\n            } else {\n                let has = false, tr = state.tr;\n                for(let i = 0; !has && i < ranges.length; i++){\n                    let { $from, $to } = ranges[i];\n                    has = state.doc.rangeHasMark($from.pos, $to.pos, markType);\n                }\n                for(let i = 0; i < ranges.length; i++){\n                    let { $from, $to } = ranges[i];\n                    if (has) {\n                        tr.removeMark($from.pos, $to.pos, markType);\n                    } else {\n                        let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore;\n                        let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n                        let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n                        if (from + spaceStart < to) {\n                            from += spaceStart;\n                            to -= spaceEnd;\n                        }\n                        tr.addMark(from, to, markType.create(attrs));\n                    }\n                }\n                dispatch(tr.scrollIntoView());\n            }\n        }\n        return true;\n    };\n}\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n    return (tr)=>{\n        if (!tr.isGeneric) return dispatch(tr);\n        let ranges = [];\n        for(let i = 0; i < tr.mapping.maps.length; i++){\n            let map = tr.mapping.maps[i];\n            for(let j = 0; j < ranges.length; j++)ranges[j] = map.map(ranges[j]);\n            map.forEach((_s, _e, from, to)=>ranges.push(from, to));\n        }\n        // Figure out which joinable points exist inside those ranges,\n        // by checking all node boundaries in their parent nodes.\n        let joinable = [];\n        for(let i = 0; i < ranges.length; i += 2){\n            let from = ranges[i], to = ranges[i + 1];\n            let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);\n            for(let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index){\n                let after = parent.maybeChild(index);\n                if (!after) break;\n                if (index && joinable.indexOf(pos) == -1) {\n                    let before = parent.child(index - 1);\n                    if (before.type == after.type && isJoinable(before, after)) joinable.push(pos);\n                }\n                pos += after.nodeSize;\n            }\n        }\n        // Join the joinable points\n        joinable.sort((a, b)=>a - b);\n        for(let i = joinable.length - 1; i >= 0; i--){\n            if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinable[i])) tr.join(joinable[i]);\n        }\n        dispatch(tr);\n    };\n}\n/**\nWrap a command so that, when it produces a transform that causes\ntwo joinable nodes to end up next to each other, those are joined.\nNodes are considered joinable when they are of the same type and\nwhen the `isJoinable` predicate returns true for them or, if an\narray of strings was passed, if their node type name is in that\narray.\n*/ function autoJoin(command, isJoinable) {\n    let canJoin = Array.isArray(isJoinable) ? (node)=>isJoinable.indexOf(node.type.name) > -1 : isJoinable;\n    return (state, dispatch, view)=>command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);\n}\n/**\nCombine a number of command functions into a single function (which\ncalls them one by one until one returns true).\n*/ function chainCommands(...commands) {\n    return function(state, dispatch, view) {\n        for(let i = 0; i < commands.length; i++)if (commands[i](state, dispatch, view)) return true;\n        return false;\n    };\n}\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward);\n/**\nA basic keymap containing bindings not specific to any schema.\nBinds the following keys (when multiple commands are listed, they\nare chained with [`chainCommands`](https://prosemirror.net/docs/ref/#commands.chainCommands)):\n\n* **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n* **Mod-Enter** to `exitCode`\n* **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n* **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-a** to `selectAll`\n*/ const pcBaseKeymap = {\n    \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n    \"Mod-Enter\": exitCode,\n    \"Backspace\": backspace,\n    \"Mod-Backspace\": backspace,\n    \"Shift-Backspace\": backspace,\n    \"Delete\": del,\n    \"Mod-Delete\": del,\n    \"Mod-a\": selectAll\n};\n/**\nA copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n**Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n**Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\nCtrl-Delete.\n*/ const macBaseKeymap = {\n    \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n    \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n    \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n    \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Ctrl-a\": selectTextblockStart,\n    \"Ctrl-e\": selectTextblockEnd\n};\nfor(let key in pcBaseKeymap)macBaseKeymap[key] = pcBaseKeymap[key];\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != \"undefined\" && os.platform ? os.platform() == \"darwin\" : false;\n/**\nDepending on the detected platform, this will hold\n[`pcBasekeymap`](https://prosemirror.net/docs/ref/#commands.pcBaseKeymap) or\n[`macBaseKeymap`](https://prosemirror.net/docs/ref/#commands.macBaseKeymap).\n*/ const baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItY29tbWFuZHMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0STtBQUN4RjtBQUNzQztBQUUxRjs7QUFFQSxHQUNBLE1BQU1jLGtCQUFrQixDQUFDQyxPQUFPQztJQUM1QixJQUFJRCxNQUFNRSxTQUFTLENBQUNDLEtBQUssRUFDckIsT0FBTztJQUNYLElBQUlGLFVBQ0FBLFNBQVNELE1BQU1JLEVBQUUsQ0FBQ0wsZUFBZSxHQUFHTSxjQUFjO0lBQ3RELE9BQU87QUFDWDtBQUNBLFNBQVNDLGFBQWFOLEtBQUssRUFBRU8sSUFBSTtJQUM3QixJQUFJLEVBQUVDLE9BQU8sRUFBRSxHQUFHUixNQUFNRSxTQUFTO0lBQ2pDLElBQUksQ0FBQ00sV0FBWUQsQ0FBQUEsT0FBTyxDQUFDQSxLQUFLRSxjQUFjLENBQUMsWUFBWVQsU0FDbkRRLFFBQVFFLFlBQVksR0FBRyxJQUN6QixPQUFPO0lBQ1gsT0FBT0Y7QUFDWDtBQUNBOzs7Ozs7OztBQVFBLEdBQ0EsTUFBTUcsZUFBZSxDQUFDWCxPQUFPQyxVQUFVTTtJQUNuQyxJQUFJQyxVQUFVRixhQUFhTixPQUFPTztJQUNsQyxJQUFJLENBQUNDLFNBQ0QsT0FBTztJQUNYLElBQUlJLE9BQU9DLGNBQWNMO0lBQ3pCLCtDQUErQztJQUMvQyxJQUFJLENBQUNJLE1BQU07UUFDUCxJQUFJRSxRQUFRTixRQUFRTyxVQUFVLElBQUlDLFNBQVNGLFNBQVM3QixpRUFBVUEsQ0FBQzZCO1FBQy9ELElBQUlFLFVBQVUsTUFDVixPQUFPO1FBQ1gsSUFBSWYsVUFDQUEsU0FBU0QsTUFBTUksRUFBRSxDQUFDYSxJQUFJLENBQUNILE9BQU9FLFFBQVFYLGNBQWM7UUFDeEQsT0FBTztJQUNYO0lBQ0EsSUFBSWEsU0FBU04sS0FBS08sVUFBVTtJQUM1Qiw4QkFBOEI7SUFDOUIsSUFBSSxDQUFDRCxPQUFPRSxJQUFJLENBQUNDLElBQUksQ0FBQ0MsU0FBUyxJQUFJQyxjQUFjdkIsT0FBT1ksTUFBTVgsV0FDMUQsT0FBTztJQUNYLHlEQUF5RDtJQUN6RCw4REFBOEQ7SUFDOUQsSUFBSU8sUUFBUWdCLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDQyxJQUFJLElBQUksS0FDOUJDLENBQUFBLFlBQVlULFFBQVEsVUFBVXZCLDREQUFhQSxDQUFDaUMsWUFBWSxDQUFDVixPQUFNLEdBQUk7UUFDcEUsSUFBSVcsVUFBVTNDLGtFQUFXQSxDQUFDYyxNQUFNOEIsR0FBRyxFQUFFdEIsUUFBUVUsTUFBTSxJQUFJVixRQUFRdUIsS0FBSyxJQUFJdEMsb0RBQUtBLENBQUNVLEtBQUs7UUFDbkYsSUFBSTBCLFdBQVdBLFFBQVFHLEtBQUssQ0FBQ04sSUFBSSxHQUFHRyxRQUFRSSxFQUFFLEdBQUdKLFFBQVFLLElBQUksRUFBRTtZQUMzRCxJQUFJakMsVUFBVTtnQkFDVixJQUFJRyxLQUFLSixNQUFNSSxFQUFFLENBQUMrQixJQUFJLENBQUNOO2dCQUN2QnpCLEdBQUdnQyxZQUFZLENBQUNULFlBQVlULFFBQVEsU0FBU3RCLHdEQUFTQSxDQUFDeUMsUUFBUSxDQUFDakMsR0FBRzBCLEdBQUcsQ0FBQ1EsT0FBTyxDQUFDbEMsR0FBR21DLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDNUIsS0FBSzZCLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUN6RzlDLDREQUFhQSxDQUFDK0MsTUFBTSxDQUFDdEMsR0FBRzBCLEdBQUcsRUFBRWxCLEtBQUs2QixHQUFHLEdBQUd2QixPQUFPeUIsUUFBUTtnQkFDN0QxQyxTQUFTRyxHQUFHQyxjQUFjO1lBQzlCO1lBQ0EsT0FBTztRQUNYO0lBQ0o7SUFDQSwyQ0FBMkM7SUFDM0MsSUFBSWEsT0FBTzBCLE1BQU0sSUFBSWhDLEtBQUtpQyxLQUFLLElBQUlyQyxRQUFRcUMsS0FBSyxHQUFHLEdBQUc7UUFDbEQsSUFBSTVDLFVBQ0FBLFNBQVNELE1BQU1JLEVBQUUsQ0FBQzBDLE1BQU0sQ0FBQ2xDLEtBQUs2QixHQUFHLEdBQUd2QixPQUFPeUIsUUFBUSxFQUFFL0IsS0FBSzZCLEdBQUcsRUFBRXBDLGNBQWM7UUFDakYsT0FBTztJQUNYO0lBQ0EsT0FBTztBQUNYO0FBQ0E7Ozs7QUFJQSxHQUNBLE1BQU0wQyx3QkFBd0IsQ0FBQy9DLE9BQU9DLFVBQVVNO0lBQzVDLElBQUlDLFVBQVVGLGFBQWFOLE9BQU9PO0lBQ2xDLElBQUksQ0FBQ0MsU0FDRCxPQUFPO0lBQ1gsSUFBSUksT0FBT0MsY0FBY0w7SUFDekIsT0FBT0ksT0FBT29DLHFCQUFxQmhELE9BQU9ZLE1BQU1YLFlBQVk7QUFDaEU7QUFDQTs7OztBQUlBLEdBQ0EsTUFBTWdELHVCQUF1QixDQUFDakQsT0FBT0MsVUFBVU07SUFDM0MsSUFBSUMsVUFBVTBDLFdBQVdsRCxPQUFPTztJQUNoQyxJQUFJLENBQUNDLFNBQ0QsT0FBTztJQUNYLElBQUlJLE9BQU91QyxhQUFhM0M7SUFDeEIsT0FBT0ksT0FBT29DLHFCQUFxQmhELE9BQU9ZLE1BQU1YLFlBQVk7QUFDaEU7QUFDQSxTQUFTK0MscUJBQXFCaEQsS0FBSyxFQUFFWSxJQUFJLEVBQUVYLFFBQVE7SUFDL0MsSUFBSWlCLFNBQVNOLEtBQUtPLFVBQVUsRUFBRWlDLGFBQWFsQyxRQUFRbUMsWUFBWXpDLEtBQUs2QixHQUFHLEdBQUc7SUFDMUUsTUFBTyxDQUFDVyxXQUFXRSxXQUFXLEVBQUVELFlBQWE7UUFDekMsSUFBSUQsV0FBV2hDLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxTQUFTLEVBQzlCLE9BQU87UUFDWCxJQUFJaUMsUUFBUUgsV0FBV0ksU0FBUztRQUNoQyxJQUFJLENBQUNELE9BQ0QsT0FBTztRQUNYSCxhQUFhRztJQUNqQjtJQUNBLElBQUl4QixRQUFRbkIsS0FBSzZDLFNBQVMsRUFBRUMsWUFBWTNCLE9BQU80QixXQUFXL0MsS0FBSzZCLEdBQUcsR0FBRztJQUNyRSxNQUFPLENBQUNpQixVQUFVSixXQUFXLEVBQUVLLFdBQVk7UUFDdkMsSUFBSUQsVUFBVXRDLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxTQUFTLEVBQzdCLE9BQU87UUFDWCxJQUFJaUMsUUFBUUcsVUFBVUUsVUFBVTtRQUNoQyxJQUFJLENBQUNMLE9BQ0QsT0FBTztRQUNYRyxZQUFZSDtJQUNoQjtJQUNBLElBQUlwQixPQUFPakQsa0VBQVdBLENBQUNjLE1BQU04QixHQUFHLEVBQUV1QixXQUFXTSxVQUFVbEUsb0RBQUtBLENBQUNVLEtBQUs7SUFDbEUsSUFBSSxDQUFDZ0MsUUFBUUEsS0FBS0QsSUFBSSxJQUFJbUIsYUFDdEJsQixnQkFBZ0JoRCw4REFBV0EsSUFBSWdELEtBQUtILEtBQUssQ0FBQ04sSUFBSSxJQUFJaUMsV0FBV04sV0FDN0QsT0FBTztJQUNYLElBQUlwRCxVQUFVO1FBQ1YsSUFBSUcsS0FBS0osTUFBTUksRUFBRSxDQUFDK0IsSUFBSSxDQUFDQTtRQUN2Qi9CLEdBQUdnQyxZQUFZLENBQUN2Qyw0REFBYUEsQ0FBQzZDLE1BQU0sQ0FBQ3RDLEdBQUcwQixHQUFHLEVBQUV1QjtRQUM3Q3BELFNBQVNHLEdBQUdDLGNBQWM7SUFDOUI7SUFDQSxPQUFPO0FBQ1g7QUFDQSxTQUFTc0IsWUFBWWtDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxPQUFPLEtBQUs7SUFDekMsSUFBSyxJQUFJQyxPQUFPSCxNQUFNRyxNQUFNQSxPQUFRRixRQUFRLFVBQVVFLEtBQUtKLFVBQVUsR0FBR0ksS0FBS1IsU0FBUyxDQUFHO1FBQ3JGLElBQUlRLEtBQUtWLFdBQVcsRUFDaEIsT0FBTztRQUNYLElBQUlTLFFBQVFDLEtBQUtDLFVBQVUsSUFBSSxHQUMzQixPQUFPO0lBQ2Y7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7Ozs7OztBQU9BLEdBQ0EsTUFBTUMscUJBQXFCLENBQUNsRSxPQUFPQyxVQUFVTTtJQUN6QyxJQUFJLEVBQUU0RCxLQUFLLEVBQUVoRSxLQUFLLEVBQUUsR0FBR0gsTUFBTUUsU0FBUyxFQUFFVSxPQUFPdUQ7SUFDL0MsSUFBSSxDQUFDaEUsT0FDRCxPQUFPO0lBQ1gsSUFBSWdFLE1BQU0zQyxNQUFNLENBQUM4QixXQUFXLEVBQUU7UUFDMUIsSUFBSS9DLE9BQU8sQ0FBQ0EsS0FBS0UsY0FBYyxDQUFDLFlBQVlULFNBQVNtRSxNQUFNekQsWUFBWSxHQUFHLEdBQ3RFLE9BQU87UUFDWEUsT0FBT0MsY0FBY3NEO0lBQ3pCO0lBQ0EsSUFBSU4sT0FBT2pELFFBQVFBLEtBQUtPLFVBQVU7SUFDbEMsSUFBSSxDQUFDMEMsUUFBUSxDQUFDbEUsNERBQWFBLENBQUNpQyxZQUFZLENBQUNpQyxPQUNyQyxPQUFPO0lBQ1gsSUFBSTVELFVBQ0FBLFNBQVNELE1BQU1JLEVBQUUsQ0FBQ2dDLFlBQVksQ0FBQ3pDLDREQUFhQSxDQUFDK0MsTUFBTSxDQUFDMUMsTUFBTThCLEdBQUcsRUFBRWxCLEtBQUs2QixHQUFHLEdBQUdvQixLQUFLbEIsUUFBUSxHQUFHdEMsY0FBYztJQUM1RyxPQUFPO0FBQ1g7QUFDQSxTQUFTUSxjQUFjdUQsSUFBSTtJQUN2QixJQUFJLENBQUNBLEtBQUs1QyxNQUFNLENBQUNKLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxTQUFTLEVBQ2hDLElBQUssSUFBSStDLElBQUlELEtBQUt2QixLQUFLLEdBQUcsR0FBR3dCLEtBQUssR0FBR0EsSUFBSztRQUN0QyxJQUFJRCxLQUFLRSxLQUFLLENBQUNELEtBQUssR0FDaEIsT0FBT0QsS0FBS3RDLEdBQUcsQ0FBQ1EsT0FBTyxDQUFDOEIsS0FBS2xELE1BQU0sQ0FBQ21ELElBQUk7UUFDNUMsSUFBSUQsS0FBS1AsSUFBSSxDQUFDUSxHQUFHakQsSUFBSSxDQUFDQyxJQUFJLENBQUNDLFNBQVMsRUFDaEM7SUFDUjtJQUNKLE9BQU87QUFDWDtBQUNBLFNBQVM0QixXQUFXbEQsS0FBSyxFQUFFTyxJQUFJO0lBQzNCLElBQUksRUFBRUMsT0FBTyxFQUFFLEdBQUdSLE1BQU1FLFNBQVM7SUFDakMsSUFBSSxDQUFDTSxXQUFZRCxDQUFBQSxPQUFPLENBQUNBLEtBQUtFLGNBQWMsQ0FBQyxXQUFXVCxTQUNsRFEsUUFBUUUsWUFBWSxHQUFHRixRQUFRZ0IsTUFBTSxDQUFDQyxPQUFPLENBQUNDLElBQUksR0FDcEQsT0FBTztJQUNYLE9BQU9sQjtBQUNYO0FBQ0E7Ozs7OztBQU1BLEdBQ0EsTUFBTStELGNBQWMsQ0FBQ3ZFLE9BQU9DLFVBQVVNO0lBQ2xDLElBQUlDLFVBQVUwQyxXQUFXbEQsT0FBT087SUFDaEMsSUFBSSxDQUFDQyxTQUNELE9BQU87SUFDWCxJQUFJSSxPQUFPdUMsYUFBYTNDO0lBQ3hCLHdEQUF3RDtJQUN4RCxJQUFJLENBQUNJLE1BQ0QsT0FBTztJQUNYLElBQUltQixRQUFRbkIsS0FBSzZDLFNBQVM7SUFDMUIsNEJBQTRCO0lBQzVCLElBQUlsQyxjQUFjdkIsT0FBT1ksTUFBTVgsV0FDM0IsT0FBTztJQUNYLHlEQUF5RDtJQUN6RCw4REFBOEQ7SUFDOUQsSUFBSU8sUUFBUWdCLE1BQU0sQ0FBQ0MsT0FBTyxDQUFDQyxJQUFJLElBQUksS0FDOUJDLENBQUFBLFlBQVlJLE9BQU8sWUFBWXBDLDREQUFhQSxDQUFDaUMsWUFBWSxDQUFDRyxNQUFLLEdBQUk7UUFDcEUsSUFBSUYsVUFBVTNDLGtFQUFXQSxDQUFDYyxNQUFNOEIsR0FBRyxFQUFFdEIsUUFBUVUsTUFBTSxJQUFJVixRQUFRdUIsS0FBSyxJQUFJdEMsb0RBQUtBLENBQUNVLEtBQUs7UUFDbkYsSUFBSTBCLFdBQVdBLFFBQVFHLEtBQUssQ0FBQ04sSUFBSSxHQUFHRyxRQUFRSSxFQUFFLEdBQUdKLFFBQVFLLElBQUksRUFBRTtZQUMzRCxJQUFJakMsVUFBVTtnQkFDVixJQUFJRyxLQUFLSixNQUFNSSxFQUFFLENBQUMrQixJQUFJLENBQUNOO2dCQUN2QnpCLEdBQUdnQyxZQUFZLENBQUNULFlBQVlJLE9BQU8sV0FBV25DLHdEQUFTQSxDQUFDeUMsUUFBUSxDQUFDakMsR0FBRzBCLEdBQUcsQ0FBQ1EsT0FBTyxDQUFDbEMsR0FBR21DLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDNUIsS0FBSzZCLEdBQUcsSUFBSSxLQUNyRzlDLDREQUFhQSxDQUFDK0MsTUFBTSxDQUFDdEMsR0FBRzBCLEdBQUcsRUFBRTFCLEdBQUdtQyxPQUFPLENBQUNDLEdBQUcsQ0FBQzVCLEtBQUs2QixHQUFHO2dCQUMxRHhDLFNBQVNHLEdBQUdDLGNBQWM7WUFDOUI7WUFDQSxPQUFPO1FBQ1g7SUFDSjtJQUNBLHlDQUF5QztJQUN6QyxJQUFJMEIsTUFBTWEsTUFBTSxJQUFJaEMsS0FBS2lDLEtBQUssSUFBSXJDLFFBQVFxQyxLQUFLLEdBQUcsR0FBRztRQUNqRCxJQUFJNUMsVUFDQUEsU0FBU0QsTUFBTUksRUFBRSxDQUFDMEMsTUFBTSxDQUFDbEMsS0FBSzZCLEdBQUcsRUFBRTdCLEtBQUs2QixHQUFHLEdBQUdWLE1BQU1ZLFFBQVEsRUFBRXRDLGNBQWM7UUFDaEYsT0FBTztJQUNYO0lBQ0EsT0FBTztBQUNYO0FBQ0E7Ozs7Ozs7QUFPQSxHQUNBLE1BQU1tRSxvQkFBb0IsQ0FBQ3hFLE9BQU9DLFVBQVVNO0lBQ3hDLElBQUksRUFBRTRELEtBQUssRUFBRWhFLEtBQUssRUFBRSxHQUFHSCxNQUFNRSxTQUFTLEVBQUVVLE9BQU91RDtJQUMvQyxJQUFJLENBQUNoRSxPQUNELE9BQU87SUFDWCxJQUFJZ0UsTUFBTTNDLE1BQU0sQ0FBQzhCLFdBQVcsRUFBRTtRQUMxQixJQUFJL0MsT0FBTyxDQUFDQSxLQUFLRSxjQUFjLENBQUMsV0FBV1QsU0FBU21FLE1BQU16RCxZQUFZLEdBQUd5RCxNQUFNM0MsTUFBTSxDQUFDQyxPQUFPLENBQUNDLElBQUksRUFDOUYsT0FBTztRQUNYZCxPQUFPdUMsYUFBYWdCO0lBQ3hCO0lBQ0EsSUFBSU4sT0FBT2pELFFBQVFBLEtBQUs2QyxTQUFTO0lBQ2pDLElBQUksQ0FBQ0ksUUFBUSxDQUFDbEUsNERBQWFBLENBQUNpQyxZQUFZLENBQUNpQyxPQUNyQyxPQUFPO0lBQ1gsSUFBSTVELFVBQ0FBLFNBQVNELE1BQU1JLEVBQUUsQ0FBQ2dDLFlBQVksQ0FBQ3pDLDREQUFhQSxDQUFDK0MsTUFBTSxDQUFDMUMsTUFBTThCLEdBQUcsRUFBRWxCLEtBQUs2QixHQUFHLEdBQUdwQyxjQUFjO0lBQzVGLE9BQU87QUFDWDtBQUNBLFNBQVM4QyxhQUFhaUIsSUFBSTtJQUN0QixJQUFJLENBQUNBLEtBQUs1QyxNQUFNLENBQUNKLElBQUksQ0FBQ0MsSUFBSSxDQUFDQyxTQUFTLEVBQ2hDLElBQUssSUFBSStDLElBQUlELEtBQUt2QixLQUFLLEdBQUcsR0FBR3dCLEtBQUssR0FBR0EsSUFBSztRQUN0QyxJQUFJN0MsU0FBUzRDLEtBQUtQLElBQUksQ0FBQ1E7UUFDdkIsSUFBSUQsS0FBS0UsS0FBSyxDQUFDRCxLQUFLLElBQUk3QyxPQUFPeUMsVUFBVSxFQUNyQyxPQUFPRyxLQUFLdEMsR0FBRyxDQUFDUSxPQUFPLENBQUM4QixLQUFLckMsS0FBSyxDQUFDc0MsSUFBSTtRQUMzQyxJQUFJN0MsT0FBT0osSUFBSSxDQUFDQyxJQUFJLENBQUNDLFNBQVMsRUFDMUI7SUFDUjtJQUNKLE9BQU87QUFDWDtBQUNBOzs7O0FBSUEsR0FDQSxNQUFNbUQsU0FBUyxDQUFDekUsT0FBT0M7SUFDbkIsSUFBSXlFLE1BQU0xRSxNQUFNRSxTQUFTLEVBQUV5RSxVQUFVRCxlQUFlL0UsNERBQWFBLEVBQUVpRjtJQUNuRSxJQUFJRCxTQUFTO1FBQ1QsSUFBSUQsSUFBSWIsSUFBSSxDQUFDUCxXQUFXLElBQUksQ0FBQ2xFLDhEQUFPQSxDQUFDWSxNQUFNOEIsR0FBRyxFQUFFNEMsSUFBSXhDLElBQUksR0FDcEQsT0FBTztRQUNYMEMsUUFBUUYsSUFBSXhDLElBQUk7SUFDcEIsT0FDSztRQUNEMEMsUUFBUXZGLGdFQUFTQSxDQUFDVyxNQUFNOEIsR0FBRyxFQUFFNEMsSUFBSXhDLElBQUksRUFBRSxDQUFDO1FBQ3hDLElBQUkwQyxTQUFTLE1BQ1QsT0FBTztJQUNmO0lBQ0EsSUFBSTNFLFVBQVU7UUFDVixJQUFJRyxLQUFLSixNQUFNSSxFQUFFLENBQUN5RSxJQUFJLENBQUNEO1FBQ3ZCLElBQUlELFNBQ0F2RSxHQUFHZ0MsWUFBWSxDQUFDekMsNERBQWFBLENBQUMrQyxNQUFNLENBQUN0QyxHQUFHMEIsR0FBRyxFQUFFOEMsUUFBUTVFLE1BQU04QixHQUFHLENBQUNRLE9BQU8sQ0FBQ3NDLE9BQU96RCxVQUFVLENBQUN3QixRQUFRO1FBQ3JHMUMsU0FBU0csR0FBR0MsY0FBYztJQUM5QjtJQUNBLE9BQU87QUFDWDtBQUNBOzs7QUFHQSxHQUNBLE1BQU15RSxXQUFXLENBQUM5RSxPQUFPQztJQUNyQixJQUFJeUUsTUFBTTFFLE1BQU1FLFNBQVMsRUFBRTBFO0lBQzNCLElBQUlGLGVBQWUvRSw0REFBYUEsRUFBRTtRQUM5QixJQUFJK0UsSUFBSWIsSUFBSSxDQUFDUCxXQUFXLElBQUksQ0FBQ2xFLDhEQUFPQSxDQUFDWSxNQUFNOEIsR0FBRyxFQUFFNEMsSUFBSXpDLEVBQUUsR0FDbEQsT0FBTztRQUNYMkMsUUFBUUYsSUFBSXpDLEVBQUU7SUFDbEIsT0FDSztRQUNEMkMsUUFBUXZGLGdFQUFTQSxDQUFDVyxNQUFNOEIsR0FBRyxFQUFFNEMsSUFBSXpDLEVBQUUsRUFBRTtRQUNyQyxJQUFJMkMsU0FBUyxNQUNULE9BQU87SUFDZjtJQUNBLElBQUkzRSxVQUNBQSxTQUFTRCxNQUFNSSxFQUFFLENBQUN5RSxJQUFJLENBQUNELE9BQU92RSxjQUFjO0lBQ2hELE9BQU87QUFDWDtBQUNBOzs7QUFHQSxHQUNBLE1BQU1ZLE9BQU8sQ0FBQ2pCLE9BQU9DO0lBQ2pCLElBQUksRUFBRThFLEtBQUssRUFBRUMsR0FBRyxFQUFFLEdBQUdoRixNQUFNRSxTQUFTO0lBQ3BDLElBQUlZLFFBQVFpRSxNQUFNaEUsVUFBVSxDQUFDaUUsTUFBTWhFLFNBQVNGLFNBQVM3QixpRUFBVUEsQ0FBQzZCO0lBQ2hFLElBQUlFLFVBQVUsTUFDVixPQUFPO0lBQ1gsSUFBSWYsVUFDQUEsU0FBU0QsTUFBTUksRUFBRSxDQUFDYSxJQUFJLENBQUNILE9BQU9FLFFBQVFYLGNBQWM7SUFDeEQsT0FBTztBQUNYO0FBQ0E7Ozs7QUFJQSxHQUNBLE1BQU00RSxnQkFBZ0IsQ0FBQ2pGLE9BQU9DO0lBQzFCLElBQUksRUFBRWtFLEtBQUssRUFBRWUsT0FBTyxFQUFFLEdBQUdsRixNQUFNRSxTQUFTO0lBQ3hDLElBQUksQ0FBQ2lFLE1BQU0zQyxNQUFNLENBQUNKLElBQUksQ0FBQ0MsSUFBSSxDQUFDOEQsSUFBSSxJQUFJLENBQUNoQixNQUFNaUIsVUFBVSxDQUFDRixVQUNsRCxPQUFPO0lBQ1gsSUFBSWpGLFVBQ0FBLFNBQVNELE1BQU1JLEVBQUUsQ0FBQ2lGLFVBQVUsQ0FBQyxNQUFNaEYsY0FBYztJQUNyRCxPQUFPO0FBQ1g7QUFDQSxTQUFTaUYsZUFBZUMsS0FBSztJQUN6QixJQUFLLElBQUlsQixJQUFJLEdBQUdBLElBQUlrQixNQUFNQyxTQUFTLEVBQUVuQixJQUFLO1FBQ3RDLElBQUksRUFBRWpELElBQUksRUFBRSxHQUFHbUUsTUFBTUUsSUFBSSxDQUFDcEI7UUFDMUIsSUFBSWpELEtBQUtrQyxXQUFXLElBQUksQ0FBQ2xDLEtBQUtzRSxnQkFBZ0IsSUFDMUMsT0FBT3RFO0lBQ2Y7SUFDQSxPQUFPO0FBQ1g7QUFDQTs7OztBQUlBLEdBQ0EsTUFBTXVFLFdBQVcsQ0FBQzNGLE9BQU9DO0lBQ3JCLElBQUksRUFBRWtFLEtBQUssRUFBRWUsT0FBTyxFQUFFLEdBQUdsRixNQUFNRSxTQUFTO0lBQ3hDLElBQUksQ0FBQ2lFLE1BQU0zQyxNQUFNLENBQUNKLElBQUksQ0FBQ0MsSUFBSSxDQUFDOEQsSUFBSSxJQUFJLENBQUNoQixNQUFNaUIsVUFBVSxDQUFDRixVQUNsRCxPQUFPO0lBQ1gsSUFBSVUsUUFBUXpCLE1BQU1OLElBQUksQ0FBQyxDQUFDLElBQUk5QixRQUFRb0MsTUFBTTBCLFVBQVUsQ0FBQyxDQUFDLElBQUl6RSxPQUFPa0UsZUFBZU0sTUFBTUUsY0FBYyxDQUFDL0Q7SUFDckcsSUFBSSxDQUFDWCxRQUFRLENBQUN3RSxNQUFNRyxjQUFjLENBQUNoRSxPQUFPQSxPQUFPWCxPQUM3QyxPQUFPO0lBQ1gsSUFBSW5CLFVBQVU7UUFDVixJQUFJd0MsTUFBTTBCLE1BQU1wQyxLQUFLLElBQUkzQixLQUFLSixNQUFNSSxFQUFFLENBQUM0RixXQUFXLENBQUN2RCxLQUFLQSxLQUFLckIsS0FBSzZFLGFBQWE7UUFDL0U3RixHQUFHZ0MsWUFBWSxDQUFDeEMsd0RBQVNBLENBQUNzRyxJQUFJLENBQUM5RixHQUFHMEIsR0FBRyxDQUFDUSxPQUFPLENBQUNHLE1BQU07UUFDcER4QyxTQUFTRyxHQUFHQyxjQUFjO0lBQzlCO0lBQ0EsT0FBTztBQUNYO0FBQ0E7OztBQUdBLEdBQ0EsTUFBTThGLHNCQUFzQixDQUFDbkcsT0FBT0M7SUFDaEMsSUFBSXlFLE1BQU0xRSxNQUFNRSxTQUFTLEVBQUUsRUFBRTZFLEtBQUssRUFBRUMsR0FBRyxFQUFFLEdBQUdOO0lBQzVDLElBQUlBLGVBQWU1RSwyREFBWUEsSUFBSWlGLE1BQU12RCxNQUFNLENBQUM0RSxhQUFhLElBQUlwQixJQUFJeEQsTUFBTSxDQUFDNEUsYUFBYSxFQUNyRixPQUFPO0lBQ1gsSUFBSWhGLE9BQU9rRSxlQUFlTixJQUFJeEQsTUFBTSxDQUFDc0UsY0FBYyxDQUFDZCxJQUFJYSxVQUFVO0lBQ2xFLElBQUksQ0FBQ3pFLFFBQVEsQ0FBQ0EsS0FBS2tDLFdBQVcsRUFDMUIsT0FBTztJQUNYLElBQUlyRCxVQUFVO1FBQ1YsSUFBSTZELE9BQU8sQ0FBQyxDQUFDaUIsTUFBTXJFLFlBQVksSUFBSXNFLElBQUlWLEtBQUssS0FBS1UsSUFBSXhELE1BQU0sQ0FBQ3lDLFVBQVUsR0FBR2MsUUFBUUMsR0FBRSxFQUFHdkMsR0FBRztRQUN6RixJQUFJckMsS0FBS0osTUFBTUksRUFBRSxDQUFDaUcsTUFBTSxDQUFDdkMsTUFBTTFDLEtBQUs2RSxhQUFhO1FBQ2pEN0YsR0FBR2dDLFlBQVksQ0FBQ3ZDLDREQUFhQSxDQUFDNkMsTUFBTSxDQUFDdEMsR0FBRzBCLEdBQUcsRUFBRWdDLE9BQU87UUFDcEQ3RCxTQUFTRyxHQUFHQyxjQUFjO0lBQzlCO0lBQ0EsT0FBTztBQUNYO0FBQ0E7OztBQUdBLEdBQ0EsTUFBTWlHLGlCQUFpQixDQUFDdEcsT0FBT0M7SUFDM0IsSUFBSSxFQUFFTyxPQUFPLEVBQUUsR0FBR1IsTUFBTUUsU0FBUztJQUNqQyxJQUFJLENBQUNNLFdBQVdBLFFBQVFnQixNQUFNLENBQUNDLE9BQU8sQ0FBQ0MsSUFBSSxFQUN2QyxPQUFPO0lBQ1gsSUFBSWxCLFFBQVFxQyxLQUFLLEdBQUcsS0FBS3JDLFFBQVF1QixLQUFLLE1BQU12QixRQUFRK0YsR0FBRyxDQUFDLENBQUMsSUFBSTtRQUN6RCxJQUFJckYsU0FBU1YsUUFBUVUsTUFBTTtRQUMzQixJQUFJNUIsK0RBQVFBLENBQUNVLE1BQU04QixHQUFHLEVBQUVaLFNBQVM7WUFDN0IsSUFBSWpCLFVBQ0FBLFNBQVNELE1BQU1JLEVBQUUsQ0FBQ29HLEtBQUssQ0FBQ3RGLFFBQVFiLGNBQWM7WUFDbEQsT0FBTztRQUNYO0lBQ0o7SUFDQSxJQUFJUyxRQUFRTixRQUFRTyxVQUFVLElBQUlDLFNBQVNGLFNBQVM3QixpRUFBVUEsQ0FBQzZCO0lBQy9ELElBQUlFLFVBQVUsTUFDVixPQUFPO0lBQ1gsSUFBSWYsVUFDQUEsU0FBU0QsTUFBTUksRUFBRSxDQUFDYSxJQUFJLENBQUNILE9BQU9FLFFBQVFYLGNBQWM7SUFDeEQsT0FBTztBQUNYO0FBQ0E7OztBQUdBLEdBQ0EsU0FBU29HLGFBQWFDLFNBQVM7SUFDM0IsT0FBTyxDQUFDMUcsT0FBT0M7UUFDWCxJQUFJLEVBQUU4RSxLQUFLLEVBQUVDLEdBQUcsRUFBRSxHQUFHaEYsTUFBTUUsU0FBUztRQUNwQyxJQUFJRixNQUFNRSxTQUFTLFlBQVlQLDREQUFhQSxJQUFJSyxNQUFNRSxTQUFTLENBQUMyRCxJQUFJLENBQUM4QyxPQUFPLEVBQUU7WUFDMUUsSUFBSSxDQUFDNUIsTUFBTXJFLFlBQVksSUFBSSxDQUFDcEIsK0RBQVFBLENBQUNVLE1BQU04QixHQUFHLEVBQUVpRCxNQUFNdEMsR0FBRyxHQUNyRCxPQUFPO1lBQ1gsSUFBSXhDLFVBQ0FBLFNBQVNELE1BQU1JLEVBQUUsQ0FBQ29HLEtBQUssQ0FBQ3pCLE1BQU10QyxHQUFHLEVBQUVwQyxjQUFjO1lBQ3JELE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQzBFLE1BQU12RCxNQUFNLENBQUNtRixPQUFPLEVBQ3JCLE9BQU87UUFDWCxJQUFJMUcsVUFBVTtZQUNWLElBQUkyRyxRQUFRNUIsSUFBSXRFLFlBQVksSUFBSXNFLElBQUl4RCxNQUFNLENBQUNDLE9BQU8sQ0FBQ0MsSUFBSTtZQUN2RCxJQUFJdEIsS0FBS0osTUFBTUksRUFBRTtZQUNqQixJQUFJSixNQUFNRSxTQUFTLFlBQVlMLDREQUFhQSxJQUFJRyxNQUFNRSxTQUFTLFlBQVlKLDJEQUFZQSxFQUNuRk0sR0FBR0wsZUFBZTtZQUN0QixJQUFJOEcsUUFBUTlCLE1BQU1sQyxLQUFLLElBQUksSUFBSSxPQUFPeUMsZUFBZVAsTUFBTWxCLElBQUksQ0FBQyxDQUFDLEdBQUdpQyxjQUFjLENBQUNmLE1BQU1jLFVBQVUsQ0FBQyxDQUFDO1lBQ3JHLElBQUlpQixZQUFZSixhQUFhQSxVQUFVMUIsSUFBSXhELE1BQU0sRUFBRW9GO1lBQ25ELElBQUlHLFFBQVFELFlBQVk7Z0JBQUNBO2FBQVUsR0FBR0YsU0FBU0MsUUFBUTtnQkFBQztvQkFBRXpGLE1BQU15RjtnQkFBTTthQUFFLEdBQUdHO1lBQzNFLElBQUlDLE1BQU0zSCwrREFBUUEsQ0FBQ2MsR0FBRzBCLEdBQUcsRUFBRTFCLEdBQUdtQyxPQUFPLENBQUNDLEdBQUcsQ0FBQ3VDLE1BQU10QyxHQUFHLEdBQUcsR0FBR3NFO1lBQ3pELElBQUksQ0FBQ0EsU0FBUyxDQUFDRSxPQUFPM0gsK0RBQVFBLENBQUNjLEdBQUcwQixHQUFHLEVBQUUxQixHQUFHbUMsT0FBTyxDQUFDQyxHQUFHLENBQUN1QyxNQUFNdEMsR0FBRyxHQUFHLEdBQUdvRSxRQUFRO2dCQUFDO29CQUFFekYsTUFBTXlGO2dCQUFNO2FBQUUsR0FBR0csWUFBWTtnQkFDekcsSUFBSUgsT0FDQUUsUUFBUTtvQkFBQzt3QkFBRTNGLE1BQU15RjtvQkFBTTtpQkFBRTtnQkFDN0JJLE1BQU07WUFDVjtZQUNBLElBQUlBLEtBQUs7Z0JBQ0w3RyxHQUFHb0csS0FBSyxDQUFDcEcsR0FBR21DLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDdUMsTUFBTXRDLEdBQUcsR0FBRyxHQUFHc0U7Z0JBQ3ZDLElBQUksQ0FBQ0gsU0FBUyxDQUFDN0IsTUFBTXJFLFlBQVksSUFBSXFFLE1BQU12RCxNQUFNLENBQUNKLElBQUksSUFBSXlGLE9BQU87b0JBQzdELElBQUlLLFFBQVE5RyxHQUFHbUMsT0FBTyxDQUFDQyxHQUFHLENBQUN1QyxNQUFNN0QsTUFBTSxLQUFLaUcsU0FBUy9HLEdBQUcwQixHQUFHLENBQUNRLE9BQU8sQ0FBQzRFO29CQUNwRSxJQUFJTCxTQUFTOUIsTUFBTWxCLElBQUksQ0FBQyxDQUFDLEdBQUdrQyxjQUFjLENBQUNvQixPQUFPN0MsS0FBSyxJQUFJNkMsT0FBTzdDLEtBQUssS0FBSyxHQUFHdUMsUUFDM0V6RyxHQUFHZ0gsYUFBYSxDQUFDaEgsR0FBR21DLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDdUMsTUFBTTdELE1BQU0sS0FBSzJGO2dCQUN6RDtZQUNKO1lBQ0E1RyxTQUFTRyxHQUFHQyxjQUFjO1FBQzlCO1FBQ0EsT0FBTztJQUNYO0FBQ0o7QUFDQTs7O0FBR0EsR0FDQSxNQUFNZ0gsYUFBYVo7QUFDbkI7OztBQUdBLEdBQ0EsTUFBTWEsc0JBQXNCLENBQUN0SCxPQUFPQztJQUNoQyxPQUFPb0gsV0FBV3JILE9BQU9DLFlBQWFHLENBQUFBLENBQUFBO1FBQ2xDLElBQUltSCxRQUFRdkgsTUFBTXdILFdBQVcsSUFBS3hILE1BQU1FLFNBQVMsQ0FBQzhFLEdBQUcsQ0FBQ3RFLFlBQVksSUFBSVYsTUFBTUUsU0FBUyxDQUFDNkUsS0FBSyxDQUFDd0MsS0FBSztRQUNqRyxJQUFJQSxPQUNBbkgsR0FBR3FILFdBQVcsQ0FBQ0Y7UUFDbkJ0SCxTQUFTRztJQUNiO0FBQ0o7QUFDQTs7O0FBR0EsR0FDQSxNQUFNc0gsbUJBQW1CLENBQUMxSCxPQUFPQztJQUM3QixJQUFJLEVBQUU4RSxLQUFLLEVBQUU5QyxFQUFFLEVBQUUsR0FBR2pDLE1BQU1FLFNBQVMsRUFBRXVDO0lBQ3JDLElBQUlrRixPQUFPNUMsTUFBTTZDLFdBQVcsQ0FBQzNGO0lBQzdCLElBQUkwRixRQUFRLEdBQ1IsT0FBTztJQUNYbEYsTUFBTXNDLE1BQU03RCxNQUFNLENBQUN5RztJQUNuQixJQUFJMUgsVUFDQUEsU0FBU0QsTUFBTUksRUFBRSxDQUFDZ0MsWUFBWSxDQUFDekMsNERBQWFBLENBQUMrQyxNQUFNLENBQUMxQyxNQUFNOEIsR0FBRyxFQUFFVztJQUNuRSxPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLE1BQU1vRixZQUFZLENBQUM3SCxPQUFPQztJQUN0QixJQUFJQSxVQUNBQSxTQUFTRCxNQUFNSSxFQUFFLENBQUNnQyxZQUFZLENBQUMsSUFBSXRDLDJEQUFZQSxDQUFDRSxNQUFNOEIsR0FBRztJQUM3RCxPQUFPO0FBQ1g7QUFDQSxTQUFTZ0csZUFBZTlILEtBQUssRUFBRW9FLElBQUksRUFBRW5FLFFBQVE7SUFDekMsSUFBSWlCLFNBQVNrRCxLQUFLakQsVUFBVSxFQUFFWSxRQUFRcUMsS0FBS1gsU0FBUyxFQUFFYSxRQUFRRixLQUFLRSxLQUFLO0lBQ3hFLElBQUksQ0FBQ3BELFVBQVUsQ0FBQ2EsU0FBUyxDQUFDYixPQUFPRSxJQUFJLENBQUMyRyxpQkFBaUIsQ0FBQ2hHLE1BQU1YLElBQUksR0FDOUQsT0FBTztJQUNYLElBQUksQ0FBQ0YsT0FBT08sT0FBTyxDQUFDQyxJQUFJLElBQUkwQyxLQUFLNUMsTUFBTSxDQUFDd0csVUFBVSxDQUFDMUQsUUFBUSxHQUFHQSxRQUFRO1FBQ2xFLElBQUlyRSxVQUNBQSxTQUFTRCxNQUFNSSxFQUFFLENBQUMwQyxNQUFNLENBQUNzQixLQUFLM0IsR0FBRyxHQUFHdkIsT0FBT3lCLFFBQVEsRUFBRXlCLEtBQUszQixHQUFHLEVBQUVwQyxjQUFjO1FBQ2pGLE9BQU87SUFDWDtJQUNBLElBQUksQ0FBQytELEtBQUs1QyxNQUFNLENBQUN3RyxVQUFVLENBQUMxRCxPQUFPQSxRQUFRLE1BQU0sQ0FBRXZDLENBQUFBLE1BQU11QixXQUFXLElBQUlsRSw4REFBT0EsQ0FBQ1ksTUFBTThCLEdBQUcsRUFBRXNDLEtBQUszQixHQUFHLElBQy9GLE9BQU87SUFDWCxJQUFJeEMsVUFDQUEsU0FBU0QsTUFBTUksRUFBRSxDQUNaNkgsaUJBQWlCLENBQUM3RCxLQUFLM0IsR0FBRyxFQUFFdkIsT0FBT0UsSUFBSSxFQUFFRixPQUFPNEUsY0FBYyxDQUFDNUUsT0FBTytDLFVBQVUsR0FDaEZZLElBQUksQ0FBQ1QsS0FBSzNCLEdBQUcsRUFDYnBDLGNBQWM7SUFDdkIsT0FBTztBQUNYO0FBQ0EsU0FBU2tCLGNBQWN2QixLQUFLLEVBQUVZLElBQUksRUFBRVgsUUFBUTtJQUN4QyxJQUFJaUIsU0FBU04sS0FBS08sVUFBVSxFQUFFWSxRQUFRbkIsS0FBSzZDLFNBQVMsRUFBRXlFLE1BQU0zQztJQUM1RCxJQUFJckUsT0FBT0UsSUFBSSxDQUFDQyxJQUFJLENBQUNDLFNBQVMsSUFBSVMsTUFBTVgsSUFBSSxDQUFDQyxJQUFJLENBQUNDLFNBQVMsRUFDdkQsT0FBTztJQUNYLElBQUl3RyxlQUFlOUgsT0FBT1ksTUFBTVgsV0FDNUIsT0FBTztJQUNYLElBQUlrSSxjQUFjdkgsS0FBS1ksTUFBTSxDQUFDd0csVUFBVSxDQUFDcEgsS0FBSzBELEtBQUssSUFBSTFELEtBQUswRCxLQUFLLEtBQUs7SUFDdEUsSUFBSTZELGVBQ0NELENBQUFBLE9BQU8sQ0FBQzNDLFFBQVFyRSxPQUFPNEUsY0FBYyxDQUFDNUUsT0FBTytDLFVBQVUsR0FBR3pFLFlBQVksQ0FBQ3VDLE1BQU1YLElBQUksTUFDbEZtRSxNQUFNNkMsU0FBUyxDQUFDRixJQUFJLENBQUMsRUFBRSxJQUFJbkcsTUFBTVgsSUFBSSxFQUFFaUgsUUFBUSxFQUFFO1FBQ2pELElBQUlwSSxVQUFVO1lBQ1YsSUFBSXNHLE1BQU0zRixLQUFLNkIsR0FBRyxHQUFHVixNQUFNWSxRQUFRLEVBQUUyRixPQUFPNUksdURBQVFBLENBQUNTLEtBQUs7WUFDMUQsSUFBSyxJQUFJa0UsSUFBSTZELEtBQUtLLE1BQU0sR0FBRyxHQUFHbEUsS0FBSyxHQUFHQSxJQUNsQ2lFLE9BQU81SSx1REFBUUEsQ0FBQ3dDLElBQUksQ0FBQ2dHLElBQUksQ0FBQzdELEVBQUUsQ0FBQzNCLE1BQU0sQ0FBQyxNQUFNNEY7WUFDOUNBLE9BQU81SSx1REFBUUEsQ0FBQ3dDLElBQUksQ0FBQ2hCLE9BQU9zSCxJQUFJLENBQUNGO1lBQ2pDLElBQUlsSSxLQUFLSixNQUFNSSxFQUFFLENBQUMrQixJQUFJLENBQUMsSUFBSTVDLG9FQUFpQkEsQ0FBQ3FCLEtBQUs2QixHQUFHLEdBQUcsR0FBRzhELEtBQUszRixLQUFLNkIsR0FBRyxFQUFFOEQsS0FBSyxJQUFJOUcsb0RBQUtBLENBQUM2SSxNQUFNLEdBQUcsSUFBSUosS0FBS0ssTUFBTSxFQUFFO1lBQ25ILElBQUlFLFNBQVNsQyxNQUFNLElBQUkyQixLQUFLSyxNQUFNO1lBQ2xDLElBQUluSiw4REFBT0EsQ0FBQ2dCLEdBQUcwQixHQUFHLEVBQUUyRyxTQUNoQnJJLEdBQUd5RSxJQUFJLENBQUM0RDtZQUNaeEksU0FBU0csR0FBR0MsY0FBYztRQUM5QjtRQUNBLE9BQU87SUFDWDtJQUNBLElBQUlxSSxXQUFXOUksd0RBQVNBLENBQUN5QyxRQUFRLENBQUN6QixNQUFNO0lBQ3hDLElBQUlFLFFBQVE0SCxZQUFZQSxTQUFTM0QsS0FBSyxDQUFDaEUsVUFBVSxDQUFDMkgsU0FBUzFELEdBQUcsR0FBR2hFLFNBQVNGLFNBQVM3QixpRUFBVUEsQ0FBQzZCO0lBQzlGLElBQUlFLFVBQVUsUUFBUUEsVUFBVUosS0FBS2lDLEtBQUssRUFBRTtRQUN4QyxJQUFJNUMsVUFDQUEsU0FBU0QsTUFBTUksRUFBRSxDQUFDYSxJQUFJLENBQUNILE9BQU9FLFFBQVFYLGNBQWM7UUFDeEQsT0FBTztJQUNYO0lBQ0EsSUFBSThILGVBQWV4RyxZQUFZSSxPQUFPLFNBQVMsU0FBU0osWUFBWVQsUUFBUSxRQUFRO1FBQ2hGLElBQUl5SCxLQUFLekgsUUFBUW9ILE9BQU8sRUFBRTtRQUMxQixPQUFTO1lBQ0xBLEtBQUtNLElBQUksQ0FBQ0Q7WUFDVixJQUFJQSxHQUFHckYsV0FBVyxFQUNkO1lBQ0pxRixLQUFLQSxHQUFHbkYsU0FBUztRQUNyQjtRQUNBLElBQUlFLFlBQVkzQixPQUFPOEcsYUFBYTtRQUNwQyxNQUFPLENBQUNuRixVQUFVSixXQUFXLEVBQUVJLFlBQVlBLFVBQVVFLFVBQVUsQ0FDM0RpRjtRQUNKLElBQUlGLEdBQUdYLFVBQVUsQ0FBQ1csR0FBRzFFLFVBQVUsRUFBRTBFLEdBQUcxRSxVQUFVLEVBQUVQLFVBQVVqQyxPQUFPLEdBQUc7WUFDaEUsSUFBSXhCLFVBQVU7Z0JBQ1YsSUFBSXNHLE1BQU03Ryx1REFBUUEsQ0FBQ1MsS0FBSztnQkFDeEIsSUFBSyxJQUFJa0UsSUFBSWlFLEtBQUtDLE1BQU0sR0FBRyxHQUFHbEUsS0FBSyxHQUFHQSxJQUNsQ2tDLE1BQU03Ryx1REFBUUEsQ0FBQ3dDLElBQUksQ0FBQ29HLElBQUksQ0FBQ2pFLEVBQUUsQ0FBQ21FLElBQUksQ0FBQ2pDO2dCQUNyQyxJQUFJbkcsS0FBS0osTUFBTUksRUFBRSxDQUFDK0IsSUFBSSxDQUFDLElBQUk1QyxvRUFBaUJBLENBQUNxQixLQUFLNkIsR0FBRyxHQUFHNkYsS0FBS0MsTUFBTSxFQUFFM0gsS0FBSzZCLEdBQUcsR0FBR1YsTUFBTVksUUFBUSxFQUFFL0IsS0FBSzZCLEdBQUcsR0FBR29HLFlBQVlqSSxLQUFLNkIsR0FBRyxHQUFHVixNQUFNWSxRQUFRLEdBQUdrRyxZQUFZLElBQUlwSixvREFBS0EsQ0FBQzhHLEtBQUsrQixLQUFLQyxNQUFNLEVBQUUsSUFBSSxHQUFHO2dCQUNsTXRJLFNBQVNHLEdBQUdDLGNBQWM7WUFDOUI7WUFDQSxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU87QUFDWDtBQUNBLFNBQVN5SSxvQkFBb0JoRixJQUFJO0lBQzdCLE9BQU8sU0FBVTlELEtBQUssRUFBRUMsUUFBUTtRQUM1QixJQUFJeUUsTUFBTTFFLE1BQU1FLFNBQVMsRUFBRWtFLE9BQU9OLE9BQU8sSUFBSVksSUFBSUssS0FBSyxHQUFHTCxJQUFJTSxHQUFHO1FBQ2hFLElBQUluQyxRQUFRdUIsS0FBS3ZCLEtBQUs7UUFDdEIsTUFBT3VCLEtBQUtQLElBQUksQ0FBQ2hCLE9BQU9rRyxRQUFRLENBQUU7WUFDOUIsSUFBSSxDQUFDbEcsT0FDRCxPQUFPO1lBQ1hBO1FBQ0o7UUFDQSxJQUFJLENBQUN1QixLQUFLUCxJQUFJLENBQUNoQixPQUFPUyxXQUFXLEVBQzdCLE9BQU87UUFDWCxJQUFJckQsVUFDQUEsU0FBU0QsTUFBTUksRUFBRSxDQUFDZ0MsWUFBWSxDQUFDdkMsNERBQWFBLENBQUM2QyxNQUFNLENBQUMxQyxNQUFNOEIsR0FBRyxFQUFFZ0MsT0FBTyxJQUFJTSxLQUFLNEUsS0FBSyxDQUFDbkcsU0FBU3VCLEtBQUttQyxHQUFHLENBQUMxRDtRQUMzRyxPQUFPO0lBQ1g7QUFDSjtBQUNBOztBQUVBLEdBQ0EsTUFBTW9HLHVCQUF1Qkgsb0JBQW9CLENBQUM7QUFDbEQ7O0FBRUEsR0FDQSxNQUFNSSxxQkFBcUJKLG9CQUFvQjtBQUMvQyx5QkFBeUI7QUFDekI7OztBQUdBLEdBQ0EsU0FBU0ssT0FBT0MsUUFBUSxFQUFFQyxRQUFRLElBQUk7SUFDbEMsT0FBTyxTQUFVckosS0FBSyxFQUFFQyxRQUFRO1FBQzVCLElBQUksRUFBRThFLEtBQUssRUFBRUMsR0FBRyxFQUFFLEdBQUdoRixNQUFNRSxTQUFTO1FBQ3BDLElBQUlZLFFBQVFpRSxNQUFNaEUsVUFBVSxDQUFDaUUsTUFBTXNFLFdBQVd4SSxTQUFTdEIsbUVBQVlBLENBQUNzQixPQUFPc0ksVUFBVUM7UUFDckYsSUFBSSxDQUFDQyxVQUNELE9BQU87UUFDWCxJQUFJckosVUFDQUEsU0FBU0QsTUFBTUksRUFBRSxDQUFDa0ksSUFBSSxDQUFDeEgsT0FBT3dJLFVBQVVqSixjQUFjO1FBQzFELE9BQU87SUFDWDtBQUNKO0FBQ0E7OztBQUdBLEdBQ0EsU0FBU2tKLGFBQWFILFFBQVEsRUFBRUMsUUFBUSxJQUFJO0lBQ3hDLE9BQU8sU0FBVXJKLEtBQUssRUFBRUMsUUFBUTtRQUM1QixJQUFJdUosYUFBYTtRQUNqQixJQUFLLElBQUluRixJQUFJLEdBQUdBLElBQUlyRSxNQUFNRSxTQUFTLENBQUN1SixNQUFNLENBQUNsQixNQUFNLElBQUksQ0FBQ2lCLFlBQVluRixJQUFLO1lBQ25FLElBQUksRUFBRVUsT0FBTyxFQUFFdEMsS0FBS1AsSUFBSSxFQUFFLEVBQUU4QyxLQUFLLEVBQUV2QyxLQUFLUixFQUFFLEVBQUUsRUFBRSxHQUFHakMsTUFBTUUsU0FBUyxDQUFDdUosTUFBTSxDQUFDcEYsRUFBRTtZQUMxRXJFLE1BQU04QixHQUFHLENBQUM0SCxZQUFZLENBQUN4SCxNQUFNRCxJQUFJLENBQUM0QixNQUFNcEI7Z0JBQ3BDLElBQUkrRyxZQUNBLE9BQU87Z0JBQ1gsSUFBSSxDQUFDM0YsS0FBS1AsV0FBVyxJQUFJTyxLQUFLOEYsU0FBUyxDQUFDUCxVQUFVQyxRQUM5QztnQkFDSixJQUFJeEYsS0FBS3pDLElBQUksSUFBSWdJLFVBQVU7b0JBQ3ZCSSxhQUFhO2dCQUNqQixPQUNLO29CQUNELElBQUlwRixPQUFPcEUsTUFBTThCLEdBQUcsQ0FBQ1EsT0FBTyxDQUFDRyxNQUFNNkIsUUFBUUYsS0FBS0UsS0FBSztvQkFDckRrRixhQUFhcEYsS0FBSzVDLE1BQU0sQ0FBQ3VFLGNBQWMsQ0FBQ3pCLE9BQU9BLFFBQVEsR0FBRzhFO2dCQUM5RDtZQUNKO1FBQ0o7UUFDQSxJQUFJLENBQUNJLFlBQ0QsT0FBTztRQUNYLElBQUl2SixVQUFVO1lBQ1YsSUFBSUcsS0FBS0osTUFBTUksRUFBRTtZQUNqQixJQUFLLElBQUlpRSxJQUFJLEdBQUdBLElBQUlyRSxNQUFNRSxTQUFTLENBQUN1SixNQUFNLENBQUNsQixNQUFNLEVBQUVsRSxJQUFLO2dCQUNwRCxJQUFJLEVBQUVVLE9BQU8sRUFBRXRDLEtBQUtQLElBQUksRUFBRSxFQUFFOEMsS0FBSyxFQUFFdkMsS0FBS1IsRUFBRSxFQUFFLEVBQUUsR0FBR2pDLE1BQU1FLFNBQVMsQ0FBQ3VKLE1BQU0sQ0FBQ3BGLEVBQUU7Z0JBQzFFakUsR0FBR21KLFlBQVksQ0FBQ3JILE1BQU1ELElBQUltSCxVQUFVQztZQUN4QztZQUNBcEosU0FBU0csR0FBR0MsY0FBYztRQUM5QjtRQUNBLE9BQU87SUFDWDtBQUNKO0FBQ0EsU0FBU3VKLFlBQVk5SCxHQUFHLEVBQUUySCxNQUFNLEVBQUVySSxJQUFJO0lBQ2xDLElBQUssSUFBSWlELElBQUksR0FBR0EsSUFBSW9GLE9BQU9sQixNQUFNLEVBQUVsRSxJQUFLO1FBQ3BDLElBQUksRUFBRVUsS0FBSyxFQUFFQyxHQUFHLEVBQUUsR0FBR3lFLE1BQU0sQ0FBQ3BGLEVBQUU7UUFDOUIsSUFBSTRDLE1BQU1sQyxNQUFNbEMsS0FBSyxJQUFJLElBQUlmLElBQUlzRSxhQUFhLElBQUl0RSxJQUFJVixJQUFJLENBQUN5SSxjQUFjLENBQUN6SSxRQUFRO1FBQ2xGVSxJQUFJNEgsWUFBWSxDQUFDM0UsTUFBTXRDLEdBQUcsRUFBRXVDLElBQUl2QyxHQUFHLEVBQUVvQixDQUFBQTtZQUNqQyxJQUFJb0QsS0FDQSxPQUFPO1lBQ1hBLE1BQU1wRCxLQUFLdUMsYUFBYSxJQUFJdkMsS0FBS3pDLElBQUksQ0FBQ3lJLGNBQWMsQ0FBQ3pJO1FBQ3pEO1FBQ0EsSUFBSTZGLEtBQ0EsT0FBTztJQUNmO0lBQ0EsT0FBTztBQUNYO0FBQ0E7Ozs7Ozs7O0FBUUEsR0FDQSxTQUFTNkMsV0FBV0MsUUFBUSxFQUFFVixRQUFRLElBQUk7SUFDdEMsT0FBTyxTQUFVckosS0FBSyxFQUFFQyxRQUFRO1FBQzVCLElBQUksRUFBRUUsS0FBSyxFQUFFSyxPQUFPLEVBQUVpSixNQUFNLEVBQUUsR0FBR3pKLE1BQU1FLFNBQVM7UUFDaEQsSUFBSSxTQUFVLENBQUNNLFdBQVksQ0FBQ29KLFlBQVk1SixNQUFNOEIsR0FBRyxFQUFFMkgsUUFBUU0sV0FDdkQsT0FBTztRQUNYLElBQUk5SixVQUFVO1lBQ1YsSUFBSU8sU0FBUztnQkFDVCxJQUFJdUosU0FBU0MsT0FBTyxDQUFDaEssTUFBTXdILFdBQVcsSUFBSWhILFFBQVErRyxLQUFLLEtBQ25EdEgsU0FBU0QsTUFBTUksRUFBRSxDQUFDNkosZ0JBQWdCLENBQUNGO3FCQUVuQzlKLFNBQVNELE1BQU1JLEVBQUUsQ0FBQzhKLGFBQWEsQ0FBQ0gsU0FBU3JILE1BQU0sQ0FBQzJHO1lBQ3hELE9BQ0s7Z0JBQ0QsSUFBSWMsTUFBTSxPQUFPL0osS0FBS0osTUFBTUksRUFBRTtnQkFDOUIsSUFBSyxJQUFJaUUsSUFBSSxHQUFHLENBQUM4RixPQUFPOUYsSUFBSW9GLE9BQU9sQixNQUFNLEVBQUVsRSxJQUFLO29CQUM1QyxJQUFJLEVBQUVVLEtBQUssRUFBRUMsR0FBRyxFQUFFLEdBQUd5RSxNQUFNLENBQUNwRixFQUFFO29CQUM5QjhGLE1BQU1uSyxNQUFNOEIsR0FBRyxDQUFDc0ksWUFBWSxDQUFDckYsTUFBTXRDLEdBQUcsRUFBRXVDLElBQUl2QyxHQUFHLEVBQUVzSDtnQkFDckQ7Z0JBQ0EsSUFBSyxJQUFJMUYsSUFBSSxHQUFHQSxJQUFJb0YsT0FBT2xCLE1BQU0sRUFBRWxFLElBQUs7b0JBQ3BDLElBQUksRUFBRVUsS0FBSyxFQUFFQyxHQUFHLEVBQUUsR0FBR3lFLE1BQU0sQ0FBQ3BGLEVBQUU7b0JBQzlCLElBQUk4RixLQUFLO3dCQUNML0osR0FBR2lLLFVBQVUsQ0FBQ3RGLE1BQU10QyxHQUFHLEVBQUV1QyxJQUFJdkMsR0FBRyxFQUFFc0g7b0JBQ3RDLE9BQ0s7d0JBQ0QsSUFBSTdILE9BQU82QyxNQUFNdEMsR0FBRyxFQUFFUixLQUFLK0MsSUFBSXZDLEdBQUcsRUFBRXVHLFFBQVFqRSxNQUFNdEIsU0FBUyxFQUFFOEMsTUFBTXZCLElBQUk3RCxVQUFVO3dCQUNqRixJQUFJbUosYUFBYXRCLFNBQVNBLE1BQU11QixNQUFNLEdBQUcsT0FBT0MsSUFBSSxDQUFDeEIsTUFBTXlCLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQ2xDLE1BQU0sR0FBRzt3QkFDN0UsSUFBSW1DLFdBQVduRSxPQUFPQSxJQUFJZ0UsTUFBTSxHQUFHLE9BQU9DLElBQUksQ0FBQ2pFLElBQUlrRSxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUNsQyxNQUFNLEdBQUc7d0JBQ3JFLElBQUlyRyxPQUFPb0ksYUFBYXJJLElBQUk7NEJBQ3hCQyxRQUFRb0k7NEJBQ1JySSxNQUFNeUk7d0JBQ1Y7d0JBQ0F0SyxHQUFHdUssT0FBTyxDQUFDekksTUFBTUQsSUFBSThILFNBQVNySCxNQUFNLENBQUMyRztvQkFDekM7Z0JBQ0o7Z0JBQ0FwSixTQUFTRyxHQUFHQyxjQUFjO1lBQzlCO1FBQ0o7UUFDQSxPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVN1SyxvQkFBb0IzSyxRQUFRLEVBQUU0SyxVQUFVO0lBQzdDLE9BQU8sQ0FBQ3pLO1FBQ0osSUFBSSxDQUFDQSxHQUFHMEssU0FBUyxFQUNiLE9BQU83SyxTQUFTRztRQUNwQixJQUFJcUosU0FBUyxFQUFFO1FBQ2YsSUFBSyxJQUFJcEYsSUFBSSxHQUFHQSxJQUFJakUsR0FBR21DLE9BQU8sQ0FBQ3dJLElBQUksQ0FBQ3hDLE1BQU0sRUFBRWxFLElBQUs7WUFDN0MsSUFBSTdCLE1BQU1wQyxHQUFHbUMsT0FBTyxDQUFDd0ksSUFBSSxDQUFDMUcsRUFBRTtZQUM1QixJQUFLLElBQUkyRyxJQUFJLEdBQUdBLElBQUl2QixPQUFPbEIsTUFBTSxFQUFFeUMsSUFDL0J2QixNQUFNLENBQUN1QixFQUFFLEdBQUd4SSxJQUFJQSxHQUFHLENBQUNpSCxNQUFNLENBQUN1QixFQUFFO1lBQ2pDeEksSUFBSXlJLE9BQU8sQ0FBQyxDQUFDQyxJQUFJQyxJQUFJakosTUFBTUQsS0FBT3dILE9BQU9iLElBQUksQ0FBQzFHLE1BQU1EO1FBQ3hEO1FBQ0EsOERBQThEO1FBQzlELHlEQUF5RDtRQUN6RCxJQUFJbUosV0FBVyxFQUFFO1FBQ2pCLElBQUssSUFBSS9HLElBQUksR0FBR0EsSUFBSW9GLE9BQU9sQixNQUFNLEVBQUVsRSxLQUFLLEVBQUc7WUFDdkMsSUFBSW5DLE9BQU91SCxNQUFNLENBQUNwRixFQUFFLEVBQUVwQyxLQUFLd0gsTUFBTSxDQUFDcEYsSUFBSSxFQUFFO1lBQ3hDLElBQUlVLFFBQVEzRSxHQUFHMEIsR0FBRyxDQUFDUSxPQUFPLENBQUNKLE9BQU9XLFFBQVFrQyxNQUFNNkMsV0FBVyxDQUFDM0YsS0FBS1QsU0FBU3VELE1BQU1sQixJQUFJLENBQUNoQjtZQUNyRixJQUFLLElBQUl5QixRQUFRUyxNQUFNYyxVQUFVLENBQUNoRCxRQUFRSixNQUFNc0MsTUFBTWhELEtBQUssQ0FBQ2MsUUFBUSxJQUFJSixPQUFPUixJQUFJLEVBQUVxQyxNQUFPO2dCQUN4RixJQUFJdkMsUUFBUVAsT0FBTzZKLFVBQVUsQ0FBQy9HO2dCQUM5QixJQUFJLENBQUN2QyxPQUNEO2dCQUNKLElBQUl1QyxTQUFTOEcsU0FBU0UsT0FBTyxDQUFDN0ksUUFBUSxDQUFDLEdBQUc7b0JBQ3RDLElBQUl2QixTQUFTTSxPQUFPK0IsS0FBSyxDQUFDZSxRQUFRO29CQUNsQyxJQUFJcEQsT0FBT0UsSUFBSSxJQUFJVyxNQUFNWCxJQUFJLElBQUl5SixXQUFXM0osUUFBUWEsUUFDaERxSixTQUFTeEMsSUFBSSxDQUFDbkc7Z0JBQ3RCO2dCQUNBQSxPQUFPVixNQUFNWSxRQUFRO1lBQ3pCO1FBQ0o7UUFDQSwyQkFBMkI7UUFDM0J5SSxTQUFTRyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsSUFBSUM7UUFDNUIsSUFBSyxJQUFJcEgsSUFBSStHLFNBQVM3QyxNQUFNLEdBQUcsR0FBR2xFLEtBQUssR0FBR0EsSUFBSztZQUMzQyxJQUFJakYsOERBQU9BLENBQUNnQixHQUFHMEIsR0FBRyxFQUFFc0osUUFBUSxDQUFDL0csRUFBRSxHQUMzQmpFLEdBQUd5RSxJQUFJLENBQUN1RyxRQUFRLENBQUMvRyxFQUFFO1FBQzNCO1FBQ0FwRSxTQUFTRztJQUNiO0FBQ0o7QUFDQTs7Ozs7OztBQU9BLEdBQ0EsU0FBU3NMLFNBQVNDLE9BQU8sRUFBRWQsVUFBVTtJQUNqQyxJQUFJekwsVUFBVXdNLE1BQU1DLE9BQU8sQ0FBQ2hCLGNBQWMsQ0FBQ2hILE9BQVNnSCxXQUFXUyxPQUFPLENBQUN6SCxLQUFLekMsSUFBSSxDQUFDMEssSUFBSSxJQUFJLENBQUMsSUFDcEZqQjtJQUNOLE9BQU8sQ0FBQzdLLE9BQU9DLFVBQVVNLE9BQVNvTCxRQUFRM0wsT0FBT0MsWUFBWTJLLG9CQUFvQjNLLFVBQVViLFVBQVVtQjtBQUN6RztBQUNBOzs7QUFHQSxHQUNBLFNBQVN3TCxjQUFjLEdBQUdDLFFBQVE7SUFDOUIsT0FBTyxTQUFVaE0sS0FBSyxFQUFFQyxRQUFRLEVBQUVNLElBQUk7UUFDbEMsSUFBSyxJQUFJOEQsSUFBSSxHQUFHQSxJQUFJMkgsU0FBU3pELE1BQU0sRUFBRWxFLElBQ2pDLElBQUkySCxRQUFRLENBQUMzSCxFQUFFLENBQUNyRSxPQUFPQyxVQUFVTSxPQUM3QixPQUFPO1FBQ2YsT0FBTztJQUNYO0FBQ0o7QUFDQSxJQUFJMEwsWUFBWUYsY0FBY2hNLGlCQUFpQlksY0FBY3VEO0FBQzdELElBQUlnSSxNQUFNSCxjQUFjaE0saUJBQWlCd0UsYUFBYUM7QUFDdEQ7Ozs7Ozs7Ozs7O0FBV0EsR0FDQSxNQUFNMkgsZUFBZTtJQUNqQixTQUFTSixjQUFjOUcsZUFBZWtCLHFCQUFxQkcsZ0JBQWdCZTtJQUMzRSxhQUFhMUI7SUFDYixhQUFhc0c7SUFDYixpQkFBaUJBO0lBQ2pCLG1CQUFtQkE7SUFDbkIsVUFBVUM7SUFDVixjQUFjQTtJQUNkLFNBQVNyRTtBQUNiO0FBQ0E7Ozs7O0FBS0EsR0FDQSxNQUFNdUUsZ0JBQWdCO0lBQ2xCLFVBQVVELFlBQVksQ0FBQyxZQUFZO0lBQ25DLGlCQUFpQkEsWUFBWSxDQUFDLGdCQUFnQjtJQUM5QyxVQUFVQSxZQUFZLENBQUMsU0FBUztJQUNoQyxzQkFBc0JBLFlBQVksQ0FBQyxhQUFhO0lBQ2hELGNBQWNBLFlBQVksQ0FBQyxhQUFhO0lBQ3hDLFNBQVNBLFlBQVksQ0FBQyxhQUFhO0lBQ25DLFVBQVVsRDtJQUNWLFVBQVVDO0FBQ2Q7QUFDQSxJQUFLLElBQUltRCxPQUFPRixhQUNaQyxhQUFhLENBQUNDLElBQUksR0FBR0YsWUFBWSxDQUFDRSxJQUFJO0FBQzFDLE1BQU1DLE1BQU0sT0FBT0MsYUFBYSxjQUFjLHFCQUFxQkMsSUFBSSxDQUFDRCxVQUFVRSxRQUFRLElBRXBGLE9BQU9DLE1BQU0sZUFBZUEsR0FBR0QsUUFBUSxHQUFHQyxHQUFHRCxRQUFRLE1BQU0sV0FBVztBQUM1RTs7OztBQUlBLEdBQ0EsTUFBTUUsYUFBYUwsTUFBTUYsZ0JBQWdCRDtBQUVpWiIsInNvdXJjZXMiOlsid2VicGFjazovL2FuYWxvZ3Vlc2hpZnRzLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWNvbW1hbmRzL2Rpc3QvaW5kZXguanM/MjhmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsaWZ0VGFyZ2V0LCByZXBsYWNlU3RlcCwgUmVwbGFjZVN0ZXAsIGNhbkpvaW4sIGpvaW5Qb2ludCwgY2FuU3BsaXQsIFJlcGxhY2VBcm91bmRTdGVwLCBmaW5kV3JhcHBpbmcgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgU2xpY2UsIEZyYWdtZW50IH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiwgU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uLCBBbGxTZWxlY3Rpb24gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbi8qKlxuRGVsZXRlIHRoZSBzZWxlY3Rpb24sIGlmIHRoZXJlIGlzIG9uZS5cbiovXG5jb25zdCBkZWxldGVTZWxlY3Rpb24gPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi5lbXB0eSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlU2VsZWN0aW9uKCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gYXRCbG9ja1N0YXJ0KHN0YXRlLCB2aWV3KSB7XG4gICAgbGV0IHsgJGN1cnNvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGN1cnNvciB8fCAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiYmFja3dhcmRcIiwgc3RhdGUpXG4gICAgICAgIDogJGN1cnNvci5wYXJlbnRPZmZzZXQgPiAwKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuICRjdXJzb3I7XG59XG4vKipcbklmIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jaywgdHJ5IHRvXG5yZWR1Y2UgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhhdCBibG9jayBhbmQgdGhlIG9uZSBiZWZvcmUgaXTigJRpZlxudGhlcmUncyBhIGJsb2NrIGRpcmVjdGx5IGJlZm9yZSBpdCB0aGF0IGNhbiBiZSBqb2luZWQsIGpvaW4gdGhlbS5cbklmIG5vdCwgdHJ5IHRvIG1vdmUgdGhlIHNlbGVjdGVkIGJsb2NrIGNsb3NlciB0byB0aGUgbmV4dCBvbmUgaW5cbnRoZSBkb2N1bWVudCBzdHJ1Y3R1cmUgYnkgbGlmdGluZyBpdCBvdXQgb2YgaXRzIHBhcmVudCBvciBtb3ZpbmcgaXRcbmludG8gYSBwYXJlbnQgb2YgdGhlIHByZXZpb3VzIGJsb2NrLiBXaWxsIHVzZSB0aGUgdmlldyBmb3IgYWNjdXJhdGVcbihiaWRpLWF3YXJlKSBzdGFydC1vZi10ZXh0YmxvY2sgZGV0ZWN0aW9uIGlmIGdpdmVuLlxuKi9cbmNvbnN0IGpvaW5CYWNrd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRjdXJzb3IpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIG5vZGUgYmVmb3JlIHRoaXMsIHRyeSB0byBsaWZ0XG4gICAgaWYgKCEkY3V0KSB7XG4gICAgICAgIGxldCByYW5nZSA9ICRjdXJzb3IuYmxvY2tSYW5nZSgpLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZTtcbiAgICAvLyBBcHBseSB0aGUgam9pbmluZyBhbGdvcml0aG1cbiAgICBpZiAoIWJlZm9yZS50eXBlLnNwZWMuaXNvbGF0aW5nICYmIGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gSWYgdGhlIG5vZGUgYmVsb3cgaGFzIG5vIGNvbnRlbnQgYW5kIHRoZSBub2RlIGFib3ZlIGlzXG4gICAgLy8gc2VsZWN0YWJsZSwgZGVsZXRlIHRoZSBub2RlIGJlbG93IGFuZCBzZWxlY3QgdGhlIG9uZSBhYm92ZS5cbiAgICBpZiAoJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiZcbiAgICAgICAgKHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikgfHwgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoYmVmb3JlKSkpIHtcbiAgICAgICAgbGV0IGRlbFN0ZXAgPSByZXBsYWNlU3RlcChzdGF0ZS5kb2MsICRjdXJzb3IuYmVmb3JlKCksICRjdXJzb3IuYWZ0ZXIoKSwgU2xpY2UuZW1wdHkpO1xuICAgICAgICBpZiAoZGVsU3RlcCAmJiBkZWxTdGVwLnNsaWNlLnNpemUgPCBkZWxTdGVwLnRvIC0gZGVsU3RlcC5mcm9tKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKGRlbFN0ZXApO1xuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbih0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpID8gU2VsZWN0aW9uLmZpbmRGcm9tKHRyLmRvYy5yZXNvbHZlKHRyLm1hcHBpbmcubWFwKCRjdXQucG9zLCAtMSkpLCAtMSlcbiAgICAgICAgICAgICAgICAgICAgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICRjdXQucG9zIC0gYmVmb3JlLm5vZGVTaXplKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgbm9kZSBiZWZvcmUgaXMgYW4gYXRvbSwgZGVsZXRlIGl0XG4gICAgaWYgKGJlZm9yZS5pc0F0b20gJiYgJGN1dC5kZXB0aCA9PSAkY3Vyc29yLmRlcHRoIC0gMSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGUoJGN1dC5wb3MgLSBiZWZvcmUubm9kZVNpemUsICRjdXQucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbkEgbW9yZSBsaW1pdGVkIGZvcm0gb2YgW2Bqb2luQmFja3dhcmRgXSgkY29tbWFuZHMuam9pbkJhY2t3YXJkKVxudGhhdCBvbmx5IHRyaWVzIHRvIGpvaW4gdGhlIGN1cnJlbnQgdGV4dGJsb2NrIHRvIHRoZSBvbmUgYmVmb3JlXG5pdCwgaWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2suXG4qL1xuY29uc3Qgam9pblRleHRibG9ja0JhY2t3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja1N0YXJ0KHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGN1cnNvcik7XG4gICAgcmV0dXJuICRjdXQgPyBqb2luVGV4dGJsb2Nrc0Fyb3VuZChzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIDogZmFsc2U7XG59O1xuLyoqXG5BIG1vcmUgbGltaXRlZCBmb3JtIG9mIFtgam9pbkZvcndhcmRgXSgkY29tbWFuZHMuam9pbkZvcndhcmQpXG50aGF0IG9ubHkgdHJpZXMgdG8gam9pbiB0aGUgY3VycmVudCB0ZXh0YmxvY2sgdG8gdGhlIG9uZSBhZnRlclxuaXQsIGlmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jay5cbiovXG5jb25zdCBqb2luVGV4dGJsb2NrRm9yd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEFmdGVyKCRjdXJzb3IpO1xuICAgIHJldHVybiAkY3V0ID8gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSA6IGZhbHNlO1xufTtcbmZ1bmN0aW9uIGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkge1xuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmUsIGJlZm9yZVRleHQgPSBiZWZvcmUsIGJlZm9yZVBvcyA9ICRjdXQucG9zIC0gMTtcbiAgICBmb3IgKDsgIWJlZm9yZVRleHQuaXNUZXh0YmxvY2s7IGJlZm9yZVBvcy0tKSB7XG4gICAgICAgIGlmIChiZWZvcmVUZXh0LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBjaGlsZCA9IGJlZm9yZVRleHQubGFzdENoaWxkO1xuICAgICAgICBpZiAoIWNoaWxkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBiZWZvcmVUZXh0ID0gY2hpbGQ7XG4gICAgfVxuICAgIGxldCBhZnRlciA9ICRjdXQubm9kZUFmdGVyLCBhZnRlclRleHQgPSBhZnRlciwgYWZ0ZXJQb3MgPSAkY3V0LnBvcyArIDE7XG4gICAgZm9yICg7ICFhZnRlclRleHQuaXNUZXh0YmxvY2s7IGFmdGVyUG9zKyspIHtcbiAgICAgICAgaWYgKGFmdGVyVGV4dC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGQgPSBhZnRlclRleHQuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgYWZ0ZXJUZXh0ID0gY2hpbGQ7XG4gICAgfVxuICAgIGxldCBzdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCBiZWZvcmVQb3MsIGFmdGVyUG9zLCBTbGljZS5lbXB0eSk7XG4gICAgaWYgKCFzdGVwIHx8IHN0ZXAuZnJvbSAhPSBiZWZvcmVQb3MgfHxcbiAgICAgICAgc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwICYmIHN0ZXAuc2xpY2Uuc2l6ZSA+PSBhZnRlclBvcyAtIGJlZm9yZVBvcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKHN0ZXApO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBiZWZvcmVQb3MpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdGV4dGJsb2NrQXQobm9kZSwgc2lkZSwgb25seSA9IGZhbHNlKSB7XG4gICAgZm9yIChsZXQgc2NhbiA9IG5vZGU7IHNjYW47IHNjYW4gPSAoc2lkZSA9PSBcInN0YXJ0XCIgPyBzY2FuLmZpcnN0Q2hpbGQgOiBzY2FuLmxhc3RDaGlsZCkpIHtcbiAgICAgICAgaWYgKHNjYW4uaXNUZXh0YmxvY2spXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKG9ubHkgJiYgc2Nhbi5jaGlsZENvdW50ICE9IDEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2ssIHNlbGVjdFxudGhlIG5vZGUgYmVmb3JlIHRoYXQgdGV4dGJsb2NrLCBpZiBwb3NzaWJsZS4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuYm91bmQgdG8ga2V5cyBsaWtlIGJhY2tzcGFjZSwgYWZ0ZXJcbltgam9pbkJhY2t3YXJkYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmpvaW5CYWNrd2FyZCkgb3Igb3RoZXIgZGVsZXRpbmdcbmNvbW1hbmRzLCBhcyBhIGZhbGwtYmFjayBiZWhhdmlvciB3aGVuIHRoZSBzY2hlbWEgZG9lc24ndCBhbGxvd1xuZGVsZXRpb24gYXQgdGhlIHNlbGVjdGVkIHBvaW50LlxuKi9cbmNvbnN0IHNlbGVjdE5vZGVCYWNrd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvbiwgJGN1dCA9ICRoZWFkO1xuICAgIGlmICghZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKSB7XG4gICAgICAgIGlmICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJiYWNrd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPiAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAkY3V0ID0gZmluZEN1dEJlZm9yZSgkaGVhZCk7XG4gICAgfVxuICAgIGxldCBub2RlID0gJGN1dCAmJiAkY3V0Lm5vZGVCZWZvcmU7XG4gICAgaWYgKCFub2RlIHx8ICFOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MgLSBub2RlLm5vZGVTaXplKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZmluZEN1dEJlZm9yZSgkcG9zKSB7XG4gICAgaWYgKCEkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBpZiAoJHBvcy5pbmRleChpKSA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuZG9jLnJlc29sdmUoJHBvcy5iZWZvcmUoaSArIDEpKTtcbiAgICAgICAgICAgIGlmICgkcG9zLm5vZGUoaSkudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYXRCbG9ja0VuZChzdGF0ZSwgdmlldykge1xuICAgIGxldCB7ICRjdXJzb3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRjdXJzb3IgfHwgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImZvcndhcmRcIiwgc3RhdGUpXG4gICAgICAgIDogJGN1cnNvci5wYXJlbnRPZmZzZXQgPCAkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gJGN1cnNvcjtcbn1cbi8qKlxuSWYgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgdGhlIGN1cnNvciBpcyBhdCB0aGUgZW5kIG9mIGFcbnRleHRibG9jaywgdHJ5IHRvIHJlZHVjZSBvciByZW1vdmUgdGhlIGJvdW5kYXJ5IGJldHdlZW4gdGhhdCBibG9ja1xuYW5kIHRoZSBvbmUgYWZ0ZXIgaXQsIGVpdGhlciBieSBqb2luaW5nIHRoZW0gb3IgYnkgbW92aW5nIHRoZSBvdGhlclxuYmxvY2sgY2xvc2VyIHRvIHRoaXMgb25lIGluIHRoZSB0cmVlIHN0cnVjdHVyZS4gV2lsbCB1c2UgdGhlIHZpZXdcbmZvciBhY2N1cmF0ZSBzdGFydC1vZi10ZXh0YmxvY2sgZGV0ZWN0aW9uIGlmIGdpdmVuLlxuKi9cbmNvbnN0IGpvaW5Gb3J3YXJkID0gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4ge1xuICAgIGxldCAkY3Vyc29yID0gYXRCbG9ja0VuZChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QWZ0ZXIoJGN1cnNvcik7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gbm9kZSBhZnRlciB0aGlzLCB0aGVyZSdzIG5vdGhpbmcgdG8gZG9cbiAgICBpZiAoISRjdXQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlcjtcbiAgICAvLyBUcnkgdGhlIGpvaW5pbmcgYWxnb3JpdGhtXG4gICAgaWYgKGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gSWYgdGhlIG5vZGUgYWJvdmUgaGFzIG5vIGNvbnRlbnQgYW5kIHRoZSBub2RlIGJlbG93IGlzXG4gICAgLy8gc2VsZWN0YWJsZSwgZGVsZXRlIHRoZSBub2RlIGFib3ZlIGFuZCBzZWxlY3QgdGhlIG9uZSBiZWxvdy5cbiAgICBpZiAoJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiZcbiAgICAgICAgKHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIpIHx8IE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGFmdGVyKSkpIHtcbiAgICAgICAgbGV0IGRlbFN0ZXAgPSByZXBsYWNlU3RlcChzdGF0ZS5kb2MsICRjdXJzb3IuYmVmb3JlKCksICRjdXJzb3IuYWZ0ZXIoKSwgU2xpY2UuZW1wdHkpO1xuICAgICAgICBpZiAoZGVsU3RlcCAmJiBkZWxTdGVwLnNsaWNlLnNpemUgPCBkZWxTdGVwLnRvIC0gZGVsU3RlcC5mcm9tKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKGRlbFN0ZXApO1xuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbih0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiKSA/IFNlbGVjdGlvbi5maW5kRnJvbSh0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcykpLCAxKVxuICAgICAgICAgICAgICAgICAgICA6IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgbmV4dCBub2RlIGlzIGFuIGF0b20sIGRlbGV0ZSBpdFxuICAgIGlmIChhZnRlci5pc0F0b20gJiYgJGN1dC5kZXB0aCA9PSAkY3Vyc29yLmRlcHRoIC0gMSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGUoJGN1dC5wb3MsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgZW5kIG9mIGEgdGV4dGJsb2NrLCBzZWxlY3RcbnRoZSBub2RlIGNvbWluZyBhZnRlciB0aGF0IHRleHRibG9jaywgaWYgcG9zc2libGUuIFRoaXMgaXMgaW50ZW5kZWRcbnRvIGJlIGJvdW5kIHRvIGtleXMgbGlrZSBkZWxldGUsIGFmdGVyXG5bYGpvaW5Gb3J3YXJkYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmpvaW5Gb3J3YXJkKSBhbmQgc2ltaWxhciBkZWxldGluZ1xuY29tbWFuZHMsIHRvIHByb3ZpZGUgYSBmYWxsLWJhY2sgYmVoYXZpb3Igd2hlbiB0aGUgc2NoZW1hIGRvZXNuJ3RcbmFsbG93IGRlbGV0aW9uIGF0IHRoZSBzZWxlY3RlZCBwb2ludC5cbiovXG5jb25zdCBzZWxlY3ROb2RlRm9yd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgeyAkaGVhZCwgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvbiwgJGN1dCA9ICRoZWFkO1xuICAgIGlmICghZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKSB7XG4gICAgICAgIGlmICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKSA6ICRoZWFkLnBhcmVudE9mZnNldCA8ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICRjdXQgPSBmaW5kQ3V0QWZ0ZXIoJGhlYWQpO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9ICRjdXQgJiYgJGN1dC5ub2RlQWZ0ZXI7XG4gICAgaWYgKCFub2RlIHx8ICFOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHN0YXRlLmRvYywgJGN1dC5wb3MpKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBmaW5kQ3V0QWZ0ZXIoJHBvcykge1xuICAgIGlmICghJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRwb3Mubm9kZShpKTtcbiAgICAgICAgICAgIGlmICgkcG9zLmluZGV4KGkpICsgMSA8IHBhcmVudC5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKCRwb3MuYWZ0ZXIoaSArIDEpKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5Kb2luIHRoZSBzZWxlY3RlZCBibG9jayBvciwgaWYgdGhlcmUgaXMgYSB0ZXh0IHNlbGVjdGlvbiwgdGhlXG5jbG9zZXN0IGFuY2VzdG9yIGJsb2NrIG9mIHRoZSBzZWxlY3Rpb24gdGhhdCBjYW4gYmUgam9pbmVkLCB3aXRoXG50aGUgc2libGluZyBhYm92ZSBpdC5cbiovXG5jb25zdCBqb2luVXAgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgbm9kZVNlbCA9IHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24sIHBvaW50O1xuICAgIGlmIChub2RlU2VsKSB7XG4gICAgICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC5mcm9tKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcG9pbnQgPSBzZWwuZnJvbTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc2VsLmZyb20sIC0xKTtcbiAgICAgICAgaWYgKHBvaW50ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5qb2luKHBvaW50KTtcbiAgICAgICAgaWYgKG5vZGVTZWwpXG4gICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBwb2ludCAtIHN0YXRlLmRvYy5yZXNvbHZlKHBvaW50KS5ub2RlQmVmb3JlLm5vZGVTaXplKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkpvaW4gdGhlIHNlbGVjdGVkIGJsb2NrLCBvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBvZiB0aGUgc2VsZWN0aW9uXG50aGF0IGNhbiBiZSBqb2luZWQsIHdpdGggdGhlIHNpYmxpbmcgYWZ0ZXIgaXQuXG4qL1xuY29uc3Qgam9pbkRvd24gPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgcG9pbnQ7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHNlbC5ub2RlLmlzVGV4dGJsb2NrIHx8ICFjYW5Kb2luKHN0YXRlLmRvYywgc2VsLnRvKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcG9pbnQgPSBzZWwudG87XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHNlbC50bywgMSk7XG4gICAgICAgIGlmIChwb2ludCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmpvaW4ocG9pbnQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuTGlmdCB0aGUgc2VsZWN0ZWQgYmxvY2ssIG9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGJsb2NrIG9mIHRoZVxuc2VsZWN0aW9uIHRoYXQgY2FuIGJlIGxpZnRlZCwgb3V0IG9mIGl0cyBwYXJlbnQgbm9kZS5cbiovXG5jb25zdCBsaWZ0ID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbklmIHRoZSBzZWxlY3Rpb24gaXMgaW4gYSBub2RlIHdob3NlIHR5cGUgaGFzIGEgdHJ1dGh5XG5bYGNvZGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuY29kZSkgcHJvcGVydHkgaW4gaXRzIHNwZWMsIHJlcGxhY2UgdGhlXG5zZWxlY3Rpb24gd2l0aCBhIG5ld2xpbmUgY2hhcmFjdGVyLlxuKi9cbmNvbnN0IG5ld2xpbmVJbkNvZGUgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRoZWFkLnBhcmVudC50eXBlLnNwZWMuY29kZSB8fCAhJGhlYWQuc2FtZVBhcmVudCgkYW5jaG9yKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuaW5zZXJ0VGV4dChcIlxcblwiKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBkZWZhdWx0QmxvY2tBdChtYXRjaCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2guZWRnZUNvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IHsgdHlwZSB9ID0gbWF0Y2guZWRnZShpKTtcbiAgICAgICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpKVxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5XaGVuIHRoZSBzZWxlY3Rpb24gaXMgaW4gYSBub2RlIHdpdGggYSB0cnV0aHlcbltgY29kZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5jb2RlKSBwcm9wZXJ0eSBpbiBpdHMgc3BlYywgY3JlYXRlIGFcbmRlZmF1bHQgYmxvY2sgYWZ0ZXIgdGhlIGNvZGUgYmxvY2ssIGFuZCBtb3ZlIHRoZSBjdXJzb3IgdGhlcmUuXG4qL1xuY29uc3QgZXhpdENvZGUgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRoZWFkLnBhcmVudC50eXBlLnNwZWMuY29kZSB8fCAhJGhlYWQuc2FtZVBhcmVudCgkYW5jaG9yKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhYm92ZSA9ICRoZWFkLm5vZGUoLTEpLCBhZnRlciA9ICRoZWFkLmluZGV4QWZ0ZXIoLTEpLCB0eXBlID0gZGVmYXVsdEJsb2NrQXQoYWJvdmUuY29udGVudE1hdGNoQXQoYWZ0ZXIpKTtcbiAgICBpZiAoIXR5cGUgfHwgIWFib3ZlLmNhblJlcGxhY2VXaXRoKGFmdGVyLCBhZnRlciwgdHlwZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHBvcyA9ICRoZWFkLmFmdGVyKCksIHRyID0gc3RhdGUudHIucmVwbGFjZVdpdGgocG9zLCBwb3MsIHR5cGUuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHBvcyksIDEpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSWYgYSBibG9jayBub2RlIGlzIHNlbGVjdGVkLCBjcmVhdGUgYW4gZW1wdHkgcGFyYWdyYXBoIGJlZm9yZSAoaWZcbml0IGlzIGl0cyBwYXJlbnQncyBmaXJzdCBjaGlsZCkgb3IgYWZ0ZXIgaXQuXG4qL1xuY29uc3QgY3JlYXRlUGFyYWdyYXBoTmVhciA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLCB7ICRmcm9tLCAkdG8gfSA9IHNlbDtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgQWxsU2VsZWN0aW9uIHx8ICRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50IHx8ICR0by5wYXJlbnQuaW5saW5lQ29udGVudClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCB0eXBlID0gZGVmYXVsdEJsb2NrQXQoJHRvLnBhcmVudC5jb250ZW50TWF0Y2hBdCgkdG8uaW5kZXhBZnRlcigpKSk7XG4gICAgaWYgKCF0eXBlIHx8ICF0eXBlLmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBzaWRlID0gKCEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJHRvLmluZGV4KCkgPCAkdG8ucGFyZW50LmNoaWxkQ291bnQgPyAkZnJvbSA6ICR0bykucG9zO1xuICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5pbnNlcnQoc2lkZSwgdHlwZS5jcmVhdGVBbmRGaWxsKCkpO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCBzaWRlICsgMSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JZiB0aGUgY3Vyc29yIGlzIGluIGFuIGVtcHR5IHRleHRibG9jayB0aGF0IGNhbiBiZSBsaWZ0ZWQsIGxpZnQgdGhlXG5ibG9jay5cbiovXG5jb25zdCBsaWZ0RW1wdHlCbG9jayA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkY3Vyc29yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkY3Vyc29yIHx8ICRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgkY3Vyc29yLmRlcHRoID4gMSAmJiAkY3Vyc29yLmFmdGVyKCkgIT0gJGN1cnNvci5lbmQoLTEpKSB7XG4gICAgICAgIGxldCBiZWZvcmUgPSAkY3Vyc29yLmJlZm9yZSgpO1xuICAgICAgICBpZiAoY2FuU3BsaXQoc3RhdGUuZG9jLCBiZWZvcmUpKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc3BsaXQoYmVmb3JlKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCByYW5nZSA9ICRjdXJzb3IuYmxvY2tSYW5nZSgpLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DcmVhdGUgYSB2YXJpYW50IG9mIFtgc3BsaXRCbG9ja2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5zcGxpdEJsb2NrKSB0aGF0IHVzZXNcbmEgY3VzdG9tIGZ1bmN0aW9uIHRvIGRldGVybWluZSB0aGUgdHlwZSBvZiB0aGUgbmV3bHkgc3BsaXQgb2ZmIGJsb2NrLlxuKi9cbmZ1bmN0aW9uIHNwbGl0QmxvY2tBcyhzcGxpdE5vZGUpIHtcbiAgICByZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHN0YXRlLnNlbGVjdGlvbi5ub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgIGlmICghJGZyb20ucGFyZW50T2Zmc2V0IHx8ICFjYW5TcGxpdChzdGF0ZS5kb2MsICRmcm9tLnBvcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNwbGl0KCRmcm9tLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISRmcm9tLnBhcmVudC5pc0Jsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBhdEVuZCA9ICR0by5wYXJlbnRPZmZzZXQgPT0gJHRvLnBhcmVudC5jb250ZW50LnNpemU7XG4gICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uIHx8IHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICB0ci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGxldCBkZWZsdCA9ICRmcm9tLmRlcHRoID09IDAgPyBudWxsIDogZGVmYXVsdEJsb2NrQXQoJGZyb20ubm9kZSgtMSkuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcigtMSkpKTtcbiAgICAgICAgICAgIGxldCBzcGxpdFR5cGUgPSBzcGxpdE5vZGUgJiYgc3BsaXROb2RlKCR0by5wYXJlbnQsIGF0RW5kKTtcbiAgICAgICAgICAgIGxldCB0eXBlcyA9IHNwbGl0VHlwZSA/IFtzcGxpdFR5cGVdIDogYXRFbmQgJiYgZGVmbHQgPyBbeyB0eXBlOiBkZWZsdCB9XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxldCBjYW4gPSBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcbiAgICAgICAgICAgIGlmICghdHlwZXMgJiYgIWNhbiAmJiBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIGRlZmx0ID8gW3sgdHlwZTogZGVmbHQgfV0gOiB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmx0KVxuICAgICAgICAgICAgICAgICAgICB0eXBlcyA9IFt7IHR5cGU6IGRlZmx0IH1dO1xuICAgICAgICAgICAgICAgIGNhbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuKSB7XG4gICAgICAgICAgICAgICAgdHIuc3BsaXQodHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xuICAgICAgICAgICAgICAgIGlmICghYXRFbmQgJiYgISRmcm9tLnBhcmVudE9mZnNldCAmJiAkZnJvbS5wYXJlbnQudHlwZSAhPSBkZWZsdCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksICRmaXJzdCA9IHRyLmRvYy5yZXNvbHZlKGZpcnN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmx0ICYmICRmcm9tLm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRmaXJzdC5pbmRleCgpLCAkZmlyc3QuaW5kZXgoKSArIDEsIGRlZmx0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAodHIubWFwcGluZy5tYXAoJGZyb20uYmVmb3JlKCkpLCBkZWZsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuU3BsaXQgdGhlIHBhcmVudCBibG9jayBvZiB0aGUgc2VsZWN0aW9uLiBJZiB0aGUgc2VsZWN0aW9uIGlzIGEgdGV4dFxuc2VsZWN0aW9uLCBhbHNvIGRlbGV0ZSBpdHMgY29udGVudC5cbiovXG5jb25zdCBzcGxpdEJsb2NrID0gc3BsaXRCbG9ja0FzKCk7XG4vKipcbkFjdHMgbGlrZSBbYHNwbGl0QmxvY2tgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuc3BsaXRCbG9jayksIGJ1dCB3aXRob3V0XG5yZXNldHRpbmcgdGhlIHNldCBvZiBhY3RpdmUgbWFya3MgYXQgdGhlIGN1cnNvci5cbiovXG5jb25zdCBzcGxpdEJsb2NrS2VlcE1hcmtzID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIHJldHVybiBzcGxpdEJsb2NrKHN0YXRlLCBkaXNwYXRjaCAmJiAodHIgPT4ge1xuICAgICAgICBsZXQgbWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyB8fCAoc3RhdGUuc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpO1xuICAgICAgICBpZiAobWFya3MpXG4gICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhtYXJrcyk7XG4gICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICB9KSk7XG59O1xuLyoqXG5Nb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIG5vZGUgd3JhcHBpbmcgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLCBpZlxuYW55LiAoV2lsbCBub3Qgc2VsZWN0IHRoZSBkb2N1bWVudCBub2RlLilcbiovXG5jb25zdCBzZWxlY3RQYXJlbnROb2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRmcm9tLCB0byB9ID0gc3RhdGUuc2VsZWN0aW9uLCBwb3M7XG4gICAgbGV0IHNhbWUgPSAkZnJvbS5zaGFyZWREZXB0aCh0byk7XG4gICAgaWYgKHNhbWUgPT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHBvcyA9ICRmcm9tLmJlZm9yZShzYW1lKTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsIHBvcykpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblNlbGVjdCB0aGUgd2hvbGUgZG9jdW1lbnQuXG4qL1xuY29uc3Qgc2VsZWN0QWxsID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBBbGxTZWxlY3Rpb24oc3RhdGUuZG9jKSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGpvaW5NYXliZUNsZWFyKHN0YXRlLCAkcG9zLCBkaXNwYXRjaCkge1xuICAgIGxldCBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmUsIGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXIsIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgIGlmICghYmVmb3JlIHx8ICFhZnRlciB8fCAhYmVmb3JlLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQoYWZ0ZXIudHlwZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWJlZm9yZS5jb250ZW50LnNpemUgJiYgJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCAtIDEsIGluZGV4KSkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5kZWxldGUoJHBvcy5wb3MgLSBiZWZvcmUubm9kZVNpemUsICRwb3MucG9zKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKSB8fCAhKGFmdGVyLmlzVGV4dGJsb2NrIHx8IGNhbkpvaW4oc3RhdGUuZG9jLCAkcG9zLnBvcykpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50clxuICAgICAgICAgICAgLmNsZWFySW5jb21wYXRpYmxlKCRwb3MucG9zLCBiZWZvcmUudHlwZSwgYmVmb3JlLmNvbnRlbnRNYXRjaEF0KGJlZm9yZS5jaGlsZENvdW50KSlcbiAgICAgICAgICAgIC5qb2luKCRwb3MucG9zKVxuICAgICAgICAgICAgLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGVsZXRlQmFycmllcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIHtcbiAgICBsZXQgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlLCBhZnRlciA9ICRjdXQubm9kZUFmdGVyLCBjb25uLCBtYXRjaDtcbiAgICBpZiAoYmVmb3JlLnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgYWZ0ZXIudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChqb2luTWF5YmVDbGVhcihzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgY2FuRGVsQWZ0ZXIgPSAkY3V0LnBhcmVudC5jYW5SZXBsYWNlKCRjdXQuaW5kZXgoKSwgJGN1dC5pbmRleCgpICsgMSk7XG4gICAgaWYgKGNhbkRlbEFmdGVyICYmXG4gICAgICAgIChjb25uID0gKG1hdGNoID0gYmVmb3JlLmNvbnRlbnRNYXRjaEF0KGJlZm9yZS5jaGlsZENvdW50KSkuZmluZFdyYXBwaW5nKGFmdGVyLnR5cGUpKSAmJlxuICAgICAgICBtYXRjaC5tYXRjaFR5cGUoY29ublswXSB8fCBhZnRlci50eXBlKS52YWxpZEVuZCkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLCB3cmFwID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY29ubi5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbShjb25uW2ldLmNyZWF0ZShudWxsLCB3cmFwKSk7XG4gICAgICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbShiZWZvcmUuY29weSh3cmFwKSk7XG4gICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkY3V0LnBvcyAtIDEsIGVuZCwgJGN1dC5wb3MsIGVuZCwgbmV3IFNsaWNlKHdyYXAsIDEsIDApLCBjb25uLmxlbmd0aCwgdHJ1ZSkpO1xuICAgICAgICAgICAgbGV0IGpvaW5BdCA9IGVuZCArIDIgKiBjb25uLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChjYW5Kb2luKHRyLmRvYywgam9pbkF0KSlcbiAgICAgICAgICAgICAgICB0ci5qb2luKGpvaW5BdCk7XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IHNlbEFmdGVyID0gU2VsZWN0aW9uLmZpbmRGcm9tKCRjdXQsIDEpO1xuICAgIGxldCByYW5nZSA9IHNlbEFmdGVyICYmIHNlbEFmdGVyLiRmcm9tLmJsb2NrUmFuZ2Uoc2VsQWZ0ZXIuJHRvKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCAhPSBudWxsICYmIHRhcmdldCA+PSAkY3V0LmRlcHRoKSB7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY2FuRGVsQWZ0ZXIgJiYgdGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIiwgdHJ1ZSkgJiYgdGV4dGJsb2NrQXQoYmVmb3JlLCBcImVuZFwiKSkge1xuICAgICAgICBsZXQgYXQgPSBiZWZvcmUsIHdyYXAgPSBbXTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgd3JhcC5wdXNoKGF0KTtcbiAgICAgICAgICAgIGlmIChhdC5pc1RleHRibG9jaylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGF0ID0gYXQubGFzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhZnRlclRleHQgPSBhZnRlciwgYWZ0ZXJEZXB0aCA9IDE7XG4gICAgICAgIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclRleHQgPSBhZnRlclRleHQuZmlyc3RDaGlsZClcbiAgICAgICAgICAgIGFmdGVyRGVwdGgrKztcbiAgICAgICAgaWYgKGF0LmNhblJlcGxhY2UoYXQuY2hpbGRDb3VudCwgYXQuY2hpbGRDb3VudCwgYWZ0ZXJUZXh0LmNvbnRlbnQpKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHdyYXAubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IEZyYWdtZW50LmZyb20od3JhcFtpXS5jb3B5KGVuZCkpO1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKCRjdXQucG9zIC0gd3JhcC5sZW5ndGgsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUsICRjdXQucG9zICsgYWZ0ZXJEZXB0aCwgJGN1dC5wb3MgKyBhZnRlci5ub2RlU2l6ZSAtIGFmdGVyRGVwdGgsIG5ldyBTbGljZShlbmQsIHdyYXAubGVuZ3RoLCAwKSwgMCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2VsZWN0VGV4dGJsb2NrU2lkZShzaWRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgJHBvcyA9IHNpZGUgPCAwID8gc2VsLiRmcm9tIDogc2VsLiR0bztcbiAgICAgICAgbGV0IGRlcHRoID0gJHBvcy5kZXB0aDtcbiAgICAgICAgd2hpbGUgKCRwb3Mubm9kZShkZXB0aCkuaXNJbmxpbmUpIHtcbiAgICAgICAgICAgIGlmICghZGVwdGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISRwb3Mubm9kZShkZXB0aCkuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsIHNpZGUgPCAwID8gJHBvcy5zdGFydChkZXB0aCkgOiAkcG9zLmVuZChkZXB0aCkpKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbk1vdmVzIHRoZSBjdXJzb3IgdG8gdGhlIHN0YXJ0IG9mIGN1cnJlbnQgdGV4dCBibG9jay5cbiovXG5jb25zdCBzZWxlY3RUZXh0YmxvY2tTdGFydCA9IHNlbGVjdFRleHRibG9ja1NpZGUoLTEpO1xuLyoqXG5Nb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBlbmQgb2YgY3VycmVudCB0ZXh0IGJsb2NrLlxuKi9cbmNvbnN0IHNlbGVjdFRleHRibG9ja0VuZCA9IHNlbGVjdFRleHRibG9ja1NpZGUoMSk7XG4vLyBQYXJhbWV0ZXJpemVkIGNvbW1hbmRzXG4vKipcbldyYXAgdGhlIHNlbGVjdGlvbiBpbiBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgd2l0aCB0aGUgZ2l2ZW5cbmF0dHJpYnV0ZXMuXG4qL1xuZnVuY3Rpb24gd3JhcEluKG5vZGVUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvKSwgd3JhcHBpbmcgPSByYW5nZSAmJiBmaW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgICAgIGlmICghd3JhcHBpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLndyYXAocmFuZ2UsIHdyYXBwaW5nKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuUmV0dXJucyBhIGNvbW1hbmQgdGhhdCB0cmllcyB0byBzZXQgdGhlIHNlbGVjdGVkIHRleHRibG9ja3MgdG8gdGhlXG5naXZlbiBub2RlIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlcy5cbiovXG5mdW5jdGlvbiBzZXRCbG9ja1R5cGUobm9kZVR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBhcHBsaWNhYmxlID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGggJiYgIWFwcGxpY2FibGU7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgJGZyb206IHsgcG9zOiBmcm9tIH0sICR0bzogeyBwb3M6IHRvIH0gfSA9IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXNbaV07XG4gICAgICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFwcGxpY2FibGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaXNUZXh0YmxvY2sgfHwgbm9kZS5oYXNNYXJrdXAobm9kZVR5cGUsIGF0dHJzKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT0gbm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGljYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgJHBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBvcyksIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgICAgICAgICAgICAgICAgICBhcHBsaWNhYmxlID0gJHBvcy5wYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4ICsgMSwgbm9kZVR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXBwbGljYWJsZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7ICRmcm9tOiB7IHBvczogZnJvbSB9LCAkdG86IHsgcG9zOiB0byB9IH0gPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgIHRyLnNldEJsb2NrVHlwZShmcm9tLCB0bywgbm9kZVR5cGUsIGF0dHJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXJrQXBwbGllcyhkb2MsIHJhbmdlcywgdHlwZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXTtcbiAgICAgICAgbGV0IGNhbiA9ICRmcm9tLmRlcHRoID09IDAgPyBkb2MuaW5saW5lQ29udGVudCAmJiBkb2MudHlwZS5hbGxvd3NNYXJrVHlwZSh0eXBlKSA6IGZhbHNlO1xuICAgICAgICBkb2Mubm9kZXNCZXR3ZWVuKCRmcm9tLnBvcywgJHRvLnBvcywgbm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FuKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhbiA9IG5vZGUuaW5saW5lQ29udGVudCAmJiBub2RlLnR5cGUuYWxsb3dzTWFya1R5cGUodHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2FuKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHRvZ2dsZXMgdGhlIGdpdmVuIG1hcmsgd2l0aCB0aGVcbmdpdmVuIGF0dHJpYnV0ZXMuIFdpbGwgcmV0dXJuIGBmYWxzZWAgd2hlbiB0aGUgY3VycmVudCBzZWxlY3Rpb25cbmRvZXNuJ3Qgc3VwcG9ydCB0aGF0IG1hcmsuIFRoaXMgd2lsbCByZW1vdmUgdGhlIG1hcmsgaWYgYW55IG1hcmtzXG5vZiB0aGF0IHR5cGUgZXhpc3QgaW4gdGhlIHNlbGVjdGlvbiwgb3IgYWRkIGl0IG90aGVyd2lzZS4gSWYgdGhlXG5zZWxlY3Rpb24gaXMgZW1wdHksIHRoaXMgYXBwbGllcyB0byB0aGUgW3N0b3JlZFxubWFya3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5zdG9yZWRNYXJrcykgaW5zdGVhZCBvZiBhIHJhbmdlIG9mIHRoZVxuZG9jdW1lbnQuXG4qL1xuZnVuY3Rpb24gdG9nZ2xlTWFyayhtYXJrVHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgZW1wdHksICRjdXJzb3IsIHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoKGVtcHR5ICYmICEkY3Vyc29yKSB8fCAhbWFya0FwcGxpZXMoc3RhdGUuZG9jLCByYW5nZXMsIG1hcmtUeXBlKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZS5pc0luU2V0KHN0YXRlLnN0b3JlZE1hcmtzIHx8ICRjdXJzb3IubWFya3MoKSkpXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnJlbW92ZVN0b3JlZE1hcmsobWFya1R5cGUpKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmFkZFN0b3JlZE1hcmsobWFya1R5cGUuY3JlYXRlKGF0dHJzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGhhcyA9IGZhbHNlLCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyAhaGFzICYmIGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICBoYXMgPSBzdGF0ZS5kb2MucmFuZ2VIYXNNYXJrKCRmcm9tLnBvcywgJHRvLnBvcywgbWFya1R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnJlbW92ZU1hcmsoJGZyb20ucG9zLCAkdG8ucG9zLCBtYXJrVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9ICRmcm9tLnBvcywgdG8gPSAkdG8ucG9zLCBzdGFydCA9ICRmcm9tLm5vZGVBZnRlciwgZW5kID0gJHRvLm5vZGVCZWZvcmU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VTdGFydCA9IHN0YXJ0ICYmIHN0YXJ0LmlzVGV4dCA/IC9eXFxzKi8uZXhlYyhzdGFydC50ZXh0KVswXS5sZW5ndGggOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlRW5kID0gZW5kICYmIGVuZC5pc1RleHQgPyAvXFxzKiQvLmV4ZWMoZW5kLnRleHQpWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSArIHNwYWNlU3RhcnQgPCB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gKz0gc3BhY2VTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byAtPSBzcGFjZUVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoZnJvbSwgdG8sIG1hcmtUeXBlLmNyZWF0ZShhdHRycykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiB3cmFwRGlzcGF0Y2hGb3JKb2luKGRpc3BhdGNoLCBpc0pvaW5hYmxlKSB7XG4gICAgcmV0dXJuICh0cikgPT4ge1xuICAgICAgICBpZiAoIXRyLmlzR2VuZXJpYylcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaCh0cik7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJhbmdlcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICByYW5nZXNbal0gPSBtYXAubWFwKHJhbmdlc1tqXSk7XG4gICAgICAgICAgICBtYXAuZm9yRWFjaCgoX3MsIF9lLCBmcm9tLCB0bykgPT4gcmFuZ2VzLnB1c2goZnJvbSwgdG8pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIGpvaW5hYmxlIHBvaW50cyBleGlzdCBpbnNpZGUgdGhvc2UgcmFuZ2VzLFxuICAgICAgICAvLyBieSBjaGVja2luZyBhbGwgbm9kZSBib3VuZGFyaWVzIGluIHRoZWlyIHBhcmVudCBub2Rlcy5cbiAgICAgICAgbGV0IGpvaW5hYmxlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1tpXSwgdG8gPSByYW5nZXNbaSArIDFdO1xuICAgICAgICAgICAgbGV0ICRmcm9tID0gdHIuZG9jLnJlc29sdmUoZnJvbSksIGRlcHRoID0gJGZyb20uc2hhcmVkRGVwdGgodG8pLCBwYXJlbnQgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gJGZyb20uaW5kZXhBZnRlcihkZXB0aCksIHBvcyA9ICRmcm9tLmFmdGVyKGRlcHRoICsgMSk7IHBvcyA8PSB0bzsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIWFmdGVyKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggJiYgam9pbmFibGUuaW5kZXhPZihwb3MpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBwYXJlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZS50eXBlID09IGFmdGVyLnR5cGUgJiYgaXNKb2luYWJsZShiZWZvcmUsIGFmdGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5hYmxlLnB1c2gocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zICs9IGFmdGVyLm5vZGVTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpvaW4gdGhlIGpvaW5hYmxlIHBvaW50c1xuICAgICAgICBqb2luYWJsZS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgIGZvciAobGV0IGkgPSBqb2luYWJsZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGNhbkpvaW4odHIuZG9jLCBqb2luYWJsZVtpXSkpXG4gICAgICAgICAgICAgICAgdHIuam9pbihqb2luYWJsZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH07XG59XG4vKipcbldyYXAgYSBjb21tYW5kIHNvIHRoYXQsIHdoZW4gaXQgcHJvZHVjZXMgYSB0cmFuc2Zvcm0gdGhhdCBjYXVzZXNcbnR3byBqb2luYWJsZSBub2RlcyB0byBlbmQgdXAgbmV4dCB0byBlYWNoIG90aGVyLCB0aG9zZSBhcmUgam9pbmVkLlxuTm9kZXMgYXJlIGNvbnNpZGVyZWQgam9pbmFibGUgd2hlbiB0aGV5IGFyZSBvZiB0aGUgc2FtZSB0eXBlIGFuZFxud2hlbiB0aGUgYGlzSm9pbmFibGVgIHByZWRpY2F0ZSByZXR1cm5zIHRydWUgZm9yIHRoZW0gb3IsIGlmIGFuXG5hcnJheSBvZiBzdHJpbmdzIHdhcyBwYXNzZWQsIGlmIHRoZWlyIG5vZGUgdHlwZSBuYW1lIGlzIGluIHRoYXRcbmFycmF5LlxuKi9cbmZ1bmN0aW9uIGF1dG9Kb2luKGNvbW1hbmQsIGlzSm9pbmFibGUpIHtcbiAgICBsZXQgY2FuSm9pbiA9IEFycmF5LmlzQXJyYXkoaXNKb2luYWJsZSkgPyAobm9kZSkgPT4gaXNKb2luYWJsZS5pbmRleE9mKG5vZGUudHlwZS5uYW1lKSA+IC0xXG4gICAgICAgIDogaXNKb2luYWJsZTtcbiAgICByZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4gY29tbWFuZChzdGF0ZSwgZGlzcGF0Y2ggJiYgd3JhcERpc3BhdGNoRm9ySm9pbihkaXNwYXRjaCwgY2FuSm9pbiksIHZpZXcpO1xufVxuLyoqXG5Db21iaW5lIGEgbnVtYmVyIG9mIGNvbW1hbmQgZnVuY3Rpb25zIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gKHdoaWNoXG5jYWxscyB0aGVtIG9uZSBieSBvbmUgdW50aWwgb25lIHJldHVybnMgdHJ1ZSkuXG4qL1xuZnVuY3Rpb24gY2hhaW5Db21tYW5kcyguLi5jb21tYW5kcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY29tbWFuZHNbaV0oc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5sZXQgYmFja3NwYWNlID0gY2hhaW5Db21tYW5kcyhkZWxldGVTZWxlY3Rpb24sIGpvaW5CYWNrd2FyZCwgc2VsZWN0Tm9kZUJhY2t3YXJkKTtcbmxldCBkZWwgPSBjaGFpbkNvbW1hbmRzKGRlbGV0ZVNlbGVjdGlvbiwgam9pbkZvcndhcmQsIHNlbGVjdE5vZGVGb3J3YXJkKTtcbi8qKlxuQSBiYXNpYyBrZXltYXAgY29udGFpbmluZyBiaW5kaW5ncyBub3Qgc3BlY2lmaWMgdG8gYW55IHNjaGVtYS5cbkJpbmRzIHRoZSBmb2xsb3dpbmcga2V5cyAod2hlbiBtdWx0aXBsZSBjb21tYW5kcyBhcmUgbGlzdGVkLCB0aGV5XG5hcmUgY2hhaW5lZCB3aXRoIFtgY2hhaW5Db21tYW5kc2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5jaGFpbkNvbW1hbmRzKSk6XG5cbiogKipFbnRlcioqIHRvIGBuZXdsaW5lSW5Db2RlYCwgYGNyZWF0ZVBhcmFncmFwaE5lYXJgLCBgbGlmdEVtcHR5QmxvY2tgLCBgc3BsaXRCbG9ja2BcbiogKipNb2QtRW50ZXIqKiB0byBgZXhpdENvZGVgXG4qICoqQmFja3NwYWNlKiogYW5kICoqTW9kLUJhY2tzcGFjZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkJhY2t3YXJkYCwgYHNlbGVjdE5vZGVCYWNrd2FyZGBcbiogKipEZWxldGUqKiBhbmQgKipNb2QtRGVsZXRlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luRm9yd2FyZGAsIGBzZWxlY3ROb2RlRm9yd2FyZGBcbiogKipNb2QtRGVsZXRlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luRm9yd2FyZGAsIGBzZWxlY3ROb2RlRm9yd2FyZGBcbiogKipNb2QtYSoqIHRvIGBzZWxlY3RBbGxgXG4qL1xuY29uc3QgcGNCYXNlS2V5bWFwID0ge1xuICAgIFwiRW50ZXJcIjogY2hhaW5Db21tYW5kcyhuZXdsaW5lSW5Db2RlLCBjcmVhdGVQYXJhZ3JhcGhOZWFyLCBsaWZ0RW1wdHlCbG9jaywgc3BsaXRCbG9jayksXG4gICAgXCJNb2QtRW50ZXJcIjogZXhpdENvZGUsXG4gICAgXCJCYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICAgIFwiTW9kLUJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gICAgXCJTaGlmdC1CYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICAgIFwiRGVsZXRlXCI6IGRlbCxcbiAgICBcIk1vZC1EZWxldGVcIjogZGVsLFxuICAgIFwiTW9kLWFcIjogc2VsZWN0QWxsXG59O1xuLyoqXG5BIGNvcHkgb2YgYHBjQmFzZUtleW1hcGAgdGhhdCBhbHNvIGJpbmRzICoqQ3RybC1oKiogbGlrZSBCYWNrc3BhY2UsXG4qKkN0cmwtZCoqIGxpa2UgRGVsZXRlLCAqKkFsdC1CYWNrc3BhY2UqKiBsaWtlIEN0cmwtQmFja3NwYWNlLCBhbmRcbioqQ3RybC1BbHQtQmFja3NwYWNlKiosICoqQWx0LURlbGV0ZSoqLCBhbmQgKipBbHQtZCoqIGxpa2VcbkN0cmwtRGVsZXRlLlxuKi9cbmNvbnN0IG1hY0Jhc2VLZXltYXAgPSB7XG4gICAgXCJDdHJsLWhcIjogcGNCYXNlS2V5bWFwW1wiQmFja3NwYWNlXCJdLFxuICAgIFwiQWx0LUJhY2tzcGFjZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtQmFja3NwYWNlXCJdLFxuICAgIFwiQ3RybC1kXCI6IHBjQmFzZUtleW1hcFtcIkRlbGV0ZVwiXSxcbiAgICBcIkN0cmwtQWx0LUJhY2tzcGFjZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICAgIFwiQWx0LURlbGV0ZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICAgIFwiQWx0LWRcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkN0cmwtYVwiOiBzZWxlY3RUZXh0YmxvY2tTdGFydCxcbiAgICBcIkN0cmwtZVwiOiBzZWxlY3RUZXh0YmxvY2tFbmRcbn07XG5mb3IgKGxldCBrZXkgaW4gcGNCYXNlS2V5bWFwKVxuICAgIG1hY0Jhc2VLZXltYXBba2V5XSA9IHBjQmFzZUtleW1hcFtrZXldO1xuY29uc3QgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gL01hY3xpUChob25lfFtvYV1kKS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIDogdHlwZW9mIG9zICE9IFwidW5kZWZpbmVkXCIgJiYgb3MucGxhdGZvcm0gPyBvcy5wbGF0Zm9ybSgpID09IFwiZGFyd2luXCIgOiBmYWxzZTtcbi8qKlxuRGVwZW5kaW5nIG9uIHRoZSBkZXRlY3RlZCBwbGF0Zm9ybSwgdGhpcyB3aWxsIGhvbGRcbltgcGNCYXNla2V5bWFwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLnBjQmFzZUtleW1hcCkgb3JcbltgbWFjQmFzZUtleW1hcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5tYWNCYXNlS2V5bWFwKS5cbiovXG5jb25zdCBiYXNlS2V5bWFwID0gbWFjID8gbWFjQmFzZUtleW1hcCA6IHBjQmFzZUtleW1hcDtcblxuZXhwb3J0IHsgYXV0b0pvaW4sIGJhc2VLZXltYXAsIGNoYWluQ29tbWFuZHMsIGNyZWF0ZVBhcmFncmFwaE5lYXIsIGRlbGV0ZVNlbGVjdGlvbiwgZXhpdENvZGUsIGpvaW5CYWNrd2FyZCwgam9pbkRvd24sIGpvaW5Gb3J3YXJkLCBqb2luVGV4dGJsb2NrQmFja3dhcmQsIGpvaW5UZXh0YmxvY2tGb3J3YXJkLCBqb2luVXAsIGxpZnQsIGxpZnRFbXB0eUJsb2NrLCBtYWNCYXNlS2V5bWFwLCBuZXdsaW5lSW5Db2RlLCBwY0Jhc2VLZXltYXAsIHNlbGVjdEFsbCwgc2VsZWN0Tm9kZUJhY2t3YXJkLCBzZWxlY3ROb2RlRm9yd2FyZCwgc2VsZWN0UGFyZW50Tm9kZSwgc2VsZWN0VGV4dGJsb2NrRW5kLCBzZWxlY3RUZXh0YmxvY2tTdGFydCwgc2V0QmxvY2tUeXBlLCBzcGxpdEJsb2NrLCBzcGxpdEJsb2NrQXMsIHNwbGl0QmxvY2tLZWVwTWFya3MsIHRvZ2dsZU1hcmssIHdyYXBJbiB9O1xuIl0sIm5hbWVzIjpbImxpZnRUYXJnZXQiLCJyZXBsYWNlU3RlcCIsIlJlcGxhY2VTdGVwIiwiY2FuSm9pbiIsImpvaW5Qb2ludCIsImNhblNwbGl0IiwiUmVwbGFjZUFyb3VuZFN0ZXAiLCJmaW5kV3JhcHBpbmciLCJTbGljZSIsIkZyYWdtZW50IiwiTm9kZVNlbGVjdGlvbiIsIlNlbGVjdGlvbiIsIlRleHRTZWxlY3Rpb24iLCJBbGxTZWxlY3Rpb24iLCJkZWxldGVTZWxlY3Rpb24iLCJzdGF0ZSIsImRpc3BhdGNoIiwic2VsZWN0aW9uIiwiZW1wdHkiLCJ0ciIsInNjcm9sbEludG9WaWV3IiwiYXRCbG9ja1N0YXJ0IiwidmlldyIsIiRjdXJzb3IiLCJlbmRPZlRleHRibG9jayIsInBhcmVudE9mZnNldCIsImpvaW5CYWNrd2FyZCIsIiRjdXQiLCJmaW5kQ3V0QmVmb3JlIiwicmFuZ2UiLCJibG9ja1JhbmdlIiwidGFyZ2V0IiwibGlmdCIsImJlZm9yZSIsIm5vZGVCZWZvcmUiLCJ0eXBlIiwic3BlYyIsImlzb2xhdGluZyIsImRlbGV0ZUJhcnJpZXIiLCJwYXJlbnQiLCJjb250ZW50Iiwic2l6ZSIsInRleHRibG9ja0F0IiwiaXNTZWxlY3RhYmxlIiwiZGVsU3RlcCIsImRvYyIsImFmdGVyIiwic2xpY2UiLCJ0byIsImZyb20iLCJzdGVwIiwic2V0U2VsZWN0aW9uIiwiZmluZEZyb20iLCJyZXNvbHZlIiwibWFwcGluZyIsIm1hcCIsInBvcyIsImNyZWF0ZSIsIm5vZGVTaXplIiwiaXNBdG9tIiwiZGVwdGgiLCJkZWxldGUiLCJqb2luVGV4dGJsb2NrQmFja3dhcmQiLCJqb2luVGV4dGJsb2Nrc0Fyb3VuZCIsImpvaW5UZXh0YmxvY2tGb3J3YXJkIiwiYXRCbG9ja0VuZCIsImZpbmRDdXRBZnRlciIsImJlZm9yZVRleHQiLCJiZWZvcmVQb3MiLCJpc1RleHRibG9jayIsImNoaWxkIiwibGFzdENoaWxkIiwibm9kZUFmdGVyIiwiYWZ0ZXJUZXh0IiwiYWZ0ZXJQb3MiLCJmaXJzdENoaWxkIiwibm9kZSIsInNpZGUiLCJvbmx5Iiwic2NhbiIsImNoaWxkQ291bnQiLCJzZWxlY3ROb2RlQmFja3dhcmQiLCIkaGVhZCIsIiRwb3MiLCJpIiwiaW5kZXgiLCJqb2luRm9yd2FyZCIsInNlbGVjdE5vZGVGb3J3YXJkIiwiam9pblVwIiwic2VsIiwibm9kZVNlbCIsInBvaW50Iiwiam9pbiIsImpvaW5Eb3duIiwiJGZyb20iLCIkdG8iLCJuZXdsaW5lSW5Db2RlIiwiJGFuY2hvciIsImNvZGUiLCJzYW1lUGFyZW50IiwiaW5zZXJ0VGV4dCIsImRlZmF1bHRCbG9ja0F0IiwibWF0Y2giLCJlZGdlQ291bnQiLCJlZGdlIiwiaGFzUmVxdWlyZWRBdHRycyIsImV4aXRDb2RlIiwiYWJvdmUiLCJpbmRleEFmdGVyIiwiY29udGVudE1hdGNoQXQiLCJjYW5SZXBsYWNlV2l0aCIsInJlcGxhY2VXaXRoIiwiY3JlYXRlQW5kRmlsbCIsIm5lYXIiLCJjcmVhdGVQYXJhZ3JhcGhOZWFyIiwiaW5saW5lQ29udGVudCIsImluc2VydCIsImxpZnRFbXB0eUJsb2NrIiwiZW5kIiwic3BsaXQiLCJzcGxpdEJsb2NrQXMiLCJzcGxpdE5vZGUiLCJpc0Jsb2NrIiwiYXRFbmQiLCJkZWZsdCIsInNwbGl0VHlwZSIsInR5cGVzIiwidW5kZWZpbmVkIiwiY2FuIiwiZmlyc3QiLCIkZmlyc3QiLCJzZXROb2RlTWFya3VwIiwic3BsaXRCbG9jayIsInNwbGl0QmxvY2tLZWVwTWFya3MiLCJtYXJrcyIsInN0b3JlZE1hcmtzIiwiZW5zdXJlTWFya3MiLCJzZWxlY3RQYXJlbnROb2RlIiwic2FtZSIsInNoYXJlZERlcHRoIiwic2VsZWN0QWxsIiwiam9pbk1heWJlQ2xlYXIiLCJjb21wYXRpYmxlQ29udGVudCIsImNhblJlcGxhY2UiLCJjbGVhckluY29tcGF0aWJsZSIsImNvbm4iLCJjYW5EZWxBZnRlciIsIm1hdGNoVHlwZSIsInZhbGlkRW5kIiwid3JhcCIsImxlbmd0aCIsImNvcHkiLCJqb2luQXQiLCJzZWxBZnRlciIsImF0IiwicHVzaCIsImFmdGVyRGVwdGgiLCJzZWxlY3RUZXh0YmxvY2tTaWRlIiwiaXNJbmxpbmUiLCJzdGFydCIsInNlbGVjdFRleHRibG9ja1N0YXJ0Iiwic2VsZWN0VGV4dGJsb2NrRW5kIiwid3JhcEluIiwibm9kZVR5cGUiLCJhdHRycyIsIndyYXBwaW5nIiwic2V0QmxvY2tUeXBlIiwiYXBwbGljYWJsZSIsInJhbmdlcyIsIm5vZGVzQmV0d2VlbiIsImhhc01hcmt1cCIsIm1hcmtBcHBsaWVzIiwiYWxsb3dzTWFya1R5cGUiLCJ0b2dnbGVNYXJrIiwibWFya1R5cGUiLCJpc0luU2V0IiwicmVtb3ZlU3RvcmVkTWFyayIsImFkZFN0b3JlZE1hcmsiLCJoYXMiLCJyYW5nZUhhc01hcmsiLCJyZW1vdmVNYXJrIiwic3BhY2VTdGFydCIsImlzVGV4dCIsImV4ZWMiLCJ0ZXh0Iiwic3BhY2VFbmQiLCJhZGRNYXJrIiwid3JhcERpc3BhdGNoRm9ySm9pbiIsImlzSm9pbmFibGUiLCJpc0dlbmVyaWMiLCJtYXBzIiwiaiIsImZvckVhY2giLCJfcyIsIl9lIiwiam9pbmFibGUiLCJtYXliZUNoaWxkIiwiaW5kZXhPZiIsInNvcnQiLCJhIiwiYiIsImF1dG9Kb2luIiwiY29tbWFuZCIsIkFycmF5IiwiaXNBcnJheSIsIm5hbWUiLCJjaGFpbkNvbW1hbmRzIiwiY29tbWFuZHMiLCJiYWNrc3BhY2UiLCJkZWwiLCJwY0Jhc2VLZXltYXAiLCJtYWNCYXNlS2V5bWFwIiwia2V5IiwibWFjIiwibmF2aWdhdG9yIiwidGVzdCIsInBsYXRmb3JtIiwib3MiLCJiYXNlS2V5bWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-commands/dist/index.js\n");

/***/ })

};
;