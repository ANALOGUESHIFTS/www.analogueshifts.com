"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-history";
exports.ids = ["vendor-chunks/prosemirror-history"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-history/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/prosemirror-history/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeHistory: () => (/* binding */ closeHistory),\n/* harmony export */   history: () => (/* binding */ history),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   redoDepth: () => (/* binding */ redoDepth),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   undoDepth: () => (/* binding */ undoDepth)\n/* harmony export */ });\n/* harmony import */ var rope_sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rope-sequence */ \"(ssr)/./node_modules/rope-sequence/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n\n\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' â€” a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount){\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0) return null;\n        let end = this.items.length;\n        for(;; end--){\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i)=>{\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map) remap.appendMap(map, mapFrom);\n            } else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return {\n            remaining: remaining,\n            transform,\n            selection: selection\n        };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for(let i = 0; i < transform.steps.length; i++){\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i) newItems.pop();\n                else oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems) lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Mapping;\n        this.items.forEach((item, i)=>{\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0) return this;\n        return new Branch(this.items.append(array.map((map)=>new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount) return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach((item)=>{\n            if (item.selection) eventCount--;\n        }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach((item)=>{\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null) return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection) eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            } else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for(let i = rebasedCount; i < newUntil; i++)newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items) branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach((item)=>{\n            if (!item.step) count++;\n        });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i)=>{\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection) events++;\n            } else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map) remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection) events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem)) items[last] = merged;\n                    else items.push(newItem);\n                }\n            } else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__[\"default\"].empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i)=>{\n        if (item.selection && n-- == 0) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(// The (forward) step map for this item.\n    map, // The inverted step\n    step, // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset){\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step) return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime, prevComposition){\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n        this.prevComposition = prevComposition;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr) return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0, -1);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    } else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo) return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime, history.prevComposition);\n        else return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n    } else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let composition = tr.getMeta(\"composition\");\n        let newGroup = history.prevTime == 0 || !appended && history.prevComposition != composition && (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n    } else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    } else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges) return false;\n    if (!transform.docChanged) return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end)=>{\n        for(let i = 0; i < prevRanges.length; i += 2)if (start <= prevRanges[i + 1] && end >= prevRanges[i]) adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(map) {\n    let result = [];\n    map.forEach((_from, _to, from, to)=>result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges) return null;\n    let result = [];\n    for(let i = 0; i < ranges.length; i += 2){\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to) result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, dispatch, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop) return;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n    dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {\n        redo,\n        historyState: newHist\n    }).scrollIntoView());\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for(let i = 0; i < plugins.length; i++)if (plugins[i].spec.historyPreserveItems) {\n            cachedPreserveItems = true;\n            break;\n        }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/ function closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"history\");\nconst closeHistoryKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/ function history(config = {}) {\n    config = {\n        depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500\n    };\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: historyKey,\n        state: {\n            init () {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n            },\n            apply (tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput (view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command) return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\n/**\nA command function that undoes the last change, if any.\n*/ const undo = (state, dispatch)=>{\n    let hist = historyKey.getState(state);\n    if (!hist || hist.done.eventCount == 0) return false;\n    if (dispatch) histTransaction(hist, state, dispatch, false);\n    return true;\n};\n/**\nA command function that redoes the last undone change, if any.\n*/ const redo = (state, dispatch)=>{\n    let hist = historyKey.getState(state);\n    if (!hist || hist.undone.eventCount == 0) return false;\n    if (dispatch) histTransaction(hist, state, dispatch, true);\n    return true;\n};\n/**\nThe amount of undoable events available in a given state.\n*/ function undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/ function redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItaGlzdG9yeS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF5QztBQUNPO0FBQ007QUFFdEQsc0VBQXNFO0FBQ3RFLHNFQUFzRTtBQUN0RSwwREFBMEQ7QUFDMUQsRUFBRTtBQUNGLG1FQUFtRTtBQUNuRSxvRUFBb0U7QUFDcEUsc0VBQXNFO0FBQ3RFLGtFQUFrRTtBQUNsRSxxQkFBcUI7QUFDckIsRUFBRTtBQUNGLHFFQUFxRTtBQUNyRSxzRUFBc0U7QUFDdEUsc0VBQXNFO0FBQ3RFLG9FQUFvRTtBQUNwRSwrQkFBK0I7QUFDL0IsdUNBQXVDO0FBQ3ZDLE1BQU1JLGtCQUFrQjtBQUN4QixNQUFNQztJQUNGQyxZQUFZQyxLQUFLLEVBQUVDLFVBQVUsQ0FBRTtRQUMzQixJQUFJLENBQUNELEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNDLFVBQVUsR0FBR0E7SUFDdEI7SUFDQSw2REFBNkQ7SUFDN0QsMkJBQTJCO0lBQzNCQyxTQUFTQyxLQUFLLEVBQUVDLGFBQWEsRUFBRTtRQUMzQixJQUFJLElBQUksQ0FBQ0gsVUFBVSxJQUFJLEdBQ25CLE9BQU87UUFDWCxJQUFJSSxNQUFNLElBQUksQ0FBQ0wsS0FBSyxDQUFDTSxNQUFNO1FBQzNCLE9BQVFELE1BQU87WUFDWCxJQUFJRSxPQUFPLElBQUksQ0FBQ1AsS0FBSyxDQUFDUSxHQUFHLENBQUNILE1BQU07WUFDaEMsSUFBSUUsS0FBS0UsU0FBUyxFQUFFO2dCQUNoQixFQUFFSjtnQkFDRjtZQUNKO1FBQ0o7UUFDQSxJQUFJSyxPQUFPQztRQUNYLElBQUlQLGVBQWU7WUFDZk0sUUFBUSxJQUFJLENBQUNFLFNBQVMsQ0FBQ1AsS0FBSyxJQUFJLENBQUNMLEtBQUssQ0FBQ00sTUFBTTtZQUM3Q0ssVUFBVUQsTUFBTUcsSUFBSSxDQUFDUCxNQUFNO1FBQy9CO1FBQ0EsSUFBSVEsWUFBWVgsTUFBTVksRUFBRTtRQUN4QixJQUFJTixXQUFX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QUFDQTs7QUFFQSxHQUNBLE1BQU15QixPQUFPLENBQUN4SSxPQUFPK0c7SUFDakIsSUFBSWlCLE9BQU90QyxXQUFXZ0QsUUFBUSxDQUFDMUk7SUFDL0IsSUFBSSxDQUFDZ0ksUUFBUUEsS0FBS2hELElBQUksQ0FBQ2xGLFVBQVUsSUFBSSxHQUNqQyxPQUFPO0lBQ1gsSUFBSWlILFVBQ0FELGdCQUFnQmtCLE1BQU1oSSxPQUFPK0csVUFBVTtJQUMzQyxPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLE1BQU1qQixPQUFPLENBQUM5RixPQUFPK0c7SUFDakIsSUFBSWlCLE9BQU90QyxXQUFXZ0QsUUFBUSxDQUFDMUk7SUFDL0IsSUFBSSxDQUFDZ0ksUUFBUUEsS0FBSy9DLE1BQU0sQ0FBQ25GLFVBQVUsSUFBSSxHQUNuQyxPQUFPO0lBQ1gsSUFBSWlILFVBQ0FELGdCQUFnQmtCLE1BQU1oSSxPQUFPK0csVUFBVTtJQUMzQyxPQUFPO0FBQ1g7QUFDQTs7QUFFQSxHQUNBLFNBQVM0QixVQUFVM0ksS0FBSztJQUNwQixJQUFJZ0ksT0FBT3RDLFdBQVdnRCxRQUFRLENBQUMxSTtJQUMvQixPQUFPZ0ksT0FBT0EsS0FBS2hELElBQUksQ0FBQ2xGLFVBQVUsR0FBRztBQUN6QztBQUNBOztBQUVBLEdBQ0EsU0FBUzhJLFVBQVU1SSxLQUFLO0lBQ3BCLElBQUlnSSxPQUFPdEMsV0FBV2dELFFBQVEsQ0FBQzFJO0lBQy9CLE9BQU9nSSxPQUFPQSxLQUFLL0MsTUFBTSxDQUFDbkYsVUFBVSxHQUFHO0FBQzNDO0FBRW1FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5hbG9ndWVzaGlmdHMvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItaGlzdG9yeS9kaXN0L2luZGV4LmpzPzlkOTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJvcGVTZXF1ZW5jZSBmcm9tICdyb3BlLXNlcXVlbmNlJztcbmltcG9ydCB7IE1hcHBpbmcgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgUGx1Z2luS2V5LCBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbi8vIFByb3NlTWlycm9yJ3MgaGlzdG9yeSBpc24ndCBzaW1wbHkgYSB3YXkgdG8gcm9sbCBiYWNrIHRvIGEgcHJldmlvdXNcbi8vIHN0YXRlLCBiZWNhdXNlIFByb3NlTWlycm9yIHN1cHBvcnRzIGFwcGx5aW5nIGNoYW5nZXMgd2l0aG91dCBhZGRpbmdcbi8vIHRoZW0gdG8gdGhlIGhpc3RvcnkgKGZvciBleGFtcGxlIGR1cmluZyBjb2xsYWJvcmF0aW9uKS5cbi8vXG4vLyBUbyB0aGlzIGVuZCwgZWFjaCAnQnJhbmNoJyAob25lIGZvciB0aGUgdW5kbyBoaXN0b3J5IGFuZCBvbmUgZm9yXG4vLyB0aGUgcmVkbyBoaXN0b3J5KSBrZWVwcyBhbiBhcnJheSBvZiAnSXRlbXMnLCB3aGljaCBjYW4gb3B0aW9uYWxseVxuLy8gaG9sZCBhIHN0ZXAgKGFuIGFjdHVhbCB1bmRvYWJsZSBjaGFuZ2UpLCBhbmQgYWx3YXlzIGhvbGQgYSBwb3NpdGlvblxuLy8gbWFwICh3aGljaCBpcyBuZWVkZWQgdG8gbW92ZSBjaGFuZ2VzIGJlbG93IHRoZW0gdG8gYXBwbHkgdG8gdGhlXG4vLyBjdXJyZW50IGRvY3VtZW50KS5cbi8vXG4vLyBBbiBpdGVtIHRoYXQgaGFzIGJvdGggYSBzdGVwIGFuZCBhIHNlbGVjdGlvbiBib29rbWFyayBpcyB0aGUgc3RhcnRcbi8vIG9mIGFuICdldmVudCcg4oCUIGEgZ3JvdXAgb2YgY2hhbmdlcyB0aGF0IHdpbGwgYmUgdW5kb25lIG9yIHJlZG9uZSBhdFxuLy8gb25jZS4gKEl0IHN0b3JlcyBvbmx5IHRoZSBib29rbWFyaywgc2luY2UgdGhhdCB3YXkgd2UgZG9uJ3QgaGF2ZSB0b1xuLy8gcHJvdmlkZSBhIGRvY3VtZW50IHVudGlsIHRoZSBzZWxlY3Rpb24gaXMgYWN0dWFsbHkgYXBwbGllZCwgd2hpY2hcbi8vIGlzIHVzZWZ1bCB3aGVuIGNvbXByZXNzaW5nLilcbi8vIFVzZWQgdG8gc2NoZWR1bGUgaGlzdG9yeSBjb21wcmVzc2lvblxuY29uc3QgbWF4X2VtcHR5X2l0ZW1zID0gNTAwO1xuY2xhc3MgQnJhbmNoIHtcbiAgICBjb25zdHJ1Y3RvcihpdGVtcywgZXZlbnRDb3VudCkge1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIHRoaXMuZXZlbnRDb3VudCA9IGV2ZW50Q291bnQ7XG4gICAgfVxuICAgIC8vIFBvcCB0aGUgbGF0ZXN0IGV2ZW50IG9mZiB0aGUgYnJhbmNoJ3MgaGlzdG9yeSBhbmQgYXBwbHkgaXRcbiAgICAvLyB0byBhIGRvY3VtZW50IHRyYW5zZm9ybS5cbiAgICBwb3BFdmVudChzdGF0ZSwgcHJlc2VydmVJdGVtcykge1xuICAgICAgICBpZiAodGhpcy5ldmVudENvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKDs7IGVuZC0tKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IHRoaXMuaXRlbXMuZ2V0KGVuZCAtIDEpO1xuICAgICAgICAgICAgaWYgKG5leHQuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLS1lbmQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlbWFwLCBtYXBGcm9tO1xuICAgICAgICBpZiAocHJlc2VydmVJdGVtcykge1xuICAgICAgICAgICAgcmVtYXAgPSB0aGlzLnJlbWFwcGluZyhlbmQsIHRoaXMuaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgIG1hcEZyb20gPSByZW1hcC5tYXBzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdHJhbnNmb3JtID0gc3RhdGUudHI7XG4gICAgICAgIGxldCBzZWxlY3Rpb24sIHJlbWFpbmluZztcbiAgICAgICAgbGV0IGFkZEFmdGVyID0gW10sIGFkZEJlZm9yZSA9IFtdO1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIGlmICghaXRlbS5zdGVwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZW1hcCkge1xuICAgICAgICAgICAgICAgICAgICByZW1hcCA9IHRoaXMucmVtYXBwaW5nKGVuZCwgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBtYXBGcm9tID0gcmVtYXAubWFwcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICAgICAgICBhZGRCZWZvcmUucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVtYXApIHtcbiAgICAgICAgICAgICAgICBhZGRCZWZvcmUucHVzaChuZXcgSXRlbShpdGVtLm1hcCkpO1xuICAgICAgICAgICAgICAgIGxldCBzdGVwID0gaXRlbS5zdGVwLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSksIG1hcDtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCAmJiB0cmFuc2Zvcm0ubWF5YmVTdGVwKHN0ZXApLmRvYykge1xuICAgICAgICAgICAgICAgICAgICBtYXAgPSB0cmFuc2Zvcm0ubWFwcGluZy5tYXBzW3RyYW5zZm9ybS5tYXBwaW5nLm1hcHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGFkZEFmdGVyLnB1c2gobmV3IEl0ZW0obWFwLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgYWRkQWZ0ZXIubGVuZ3RoICsgYWRkQmVmb3JlLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICAgICAgaWYgKG1hcClcbiAgICAgICAgICAgICAgICAgICAgcmVtYXAuYXBwZW5kTWFwKG1hcCwgbWFwRnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm0ubWF5YmVTdGVwKGl0ZW0uc3RlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSByZW1hcCA/IGl0ZW0uc2VsZWN0aW9uLm1hcChyZW1hcC5zbGljZShtYXBGcm9tKSkgOiBpdGVtLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICByZW1haW5pbmcgPSBuZXcgQnJhbmNoKHRoaXMuaXRlbXMuc2xpY2UoMCwgZW5kKS5hcHBlbmQoYWRkQmVmb3JlLnJldmVyc2UoKS5jb25jYXQoYWRkQWZ0ZXIpKSwgdGhpcy5ldmVudENvdW50IC0gMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLml0ZW1zLmxlbmd0aCwgMCk7XG4gICAgICAgIHJldHVybiB7IHJlbWFpbmluZzogcmVtYWluaW5nLCB0cmFuc2Zvcm0sIHNlbGVjdGlvbjogc2VsZWN0aW9uIH07XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIG5ldyBicmFuY2ggd2l0aCB0aGUgZ2l2ZW4gdHJhbnNmb3JtIGFkZGVkLlxuICAgIGFkZFRyYW5zZm9ybSh0cmFuc2Zvcm0sIHNlbGVjdGlvbiwgaGlzdE9wdGlvbnMsIHByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgbGV0IG5ld0l0ZW1zID0gW10sIGV2ZW50Q291bnQgPSB0aGlzLmV2ZW50Q291bnQ7XG4gICAgICAgIGxldCBvbGRJdGVtcyA9IHRoaXMuaXRlbXMsIGxhc3RJdGVtID0gIXByZXNlcnZlSXRlbXMgJiYgb2xkSXRlbXMubGVuZ3RoID8gb2xkSXRlbXMuZ2V0KG9sZEl0ZW1zLmxlbmd0aCAtIDEpIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2Zvcm0uc3RlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGVwID0gdHJhbnNmb3JtLnN0ZXBzW2ldLmludmVydCh0cmFuc2Zvcm0uZG9jc1tpXSk7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IG5ldyBJdGVtKHRyYW5zZm9ybS5tYXBwaW5nLm1hcHNbaV0sIHN0ZXAsIHNlbGVjdGlvbiksIG1lcmdlZDtcbiAgICAgICAgICAgIGlmIChtZXJnZWQgPSBsYXN0SXRlbSAmJiBsYXN0SXRlbS5tZXJnZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBtZXJnZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgICAgIG5ld0l0ZW1zLnBvcCgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgb2xkSXRlbXMgPSBvbGRJdGVtcy5zbGljZSgwLCBvbGRJdGVtcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0l0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRDb3VudCsrO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcHJlc2VydmVJdGVtcylcbiAgICAgICAgICAgICAgICBsYXN0SXRlbSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG92ZXJmbG93ID0gZXZlbnRDb3VudCAtIGhpc3RPcHRpb25zLmRlcHRoO1xuICAgICAgICBpZiAob3ZlcmZsb3cgPiBERVBUSF9PVkVSRkxPVykge1xuICAgICAgICAgICAgb2xkSXRlbXMgPSBjdXRPZmZFdmVudHMob2xkSXRlbXMsIG92ZXJmbG93KTtcbiAgICAgICAgICAgIGV2ZW50Q291bnQgLT0gb3ZlcmZsb3c7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCcmFuY2gob2xkSXRlbXMuYXBwZW5kKG5ld0l0ZW1zKSwgZXZlbnRDb3VudCk7XG4gICAgfVxuICAgIHJlbWFwcGluZyhmcm9tLCB0bykge1xuICAgICAgICBsZXQgbWFwcyA9IG5ldyBNYXBwaW5nO1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBtaXJyb3JQb3MgPSBpdGVtLm1pcnJvck9mZnNldCAhPSBudWxsICYmIGkgLSBpdGVtLm1pcnJvck9mZnNldCA+PSBmcm9tXG4gICAgICAgICAgICAgICAgPyBtYXBzLm1hcHMubGVuZ3RoIC0gaXRlbS5taXJyb3JPZmZzZXQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBtYXBzLmFwcGVuZE1hcChpdGVtLm1hcCwgbWlycm9yUG9zKTtcbiAgICAgICAgfSwgZnJvbSwgdG8pO1xuICAgICAgICByZXR1cm4gbWFwcztcbiAgICB9XG4gICAgYWRkTWFwcyhhcnJheSkge1xuICAgICAgICBpZiAodGhpcy5ldmVudENvdW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBCcmFuY2godGhpcy5pdGVtcy5hcHBlbmQoYXJyYXkubWFwKG1hcCA9PiBuZXcgSXRlbShtYXApKSksIHRoaXMuZXZlbnRDb3VudCk7XG4gICAgfVxuICAgIC8vIFdoZW4gdGhlIGNvbGxhYiBtb2R1bGUgcmVjZWl2ZXMgcmVtb3RlIGNoYW5nZXMsIHRoZSBoaXN0b3J5IGhhc1xuICAgIC8vIHRvIGtub3cgYWJvdXQgdGhvc2UsIHNvIHRoYXQgaXQgY2FuIGFkanVzdCB0aGUgc3RlcHMgdGhhdCB3ZXJlXG4gICAgLy8gcmViYXNlZCBvbiB0b3Agb2YgdGhlIHJlbW90ZSBjaGFuZ2VzLCBhbmQgaW5jbHVkZSB0aGUgcG9zaXRpb25cbiAgICAvLyBtYXBzIGZvciB0aGUgcmVtb3RlIGNoYW5nZXMgaW4gaXRzIGFycmF5IG9mIGl0ZW1zLlxuICAgIHJlYmFzZWQocmViYXNlZFRyYW5zZm9ybSwgcmViYXNlZENvdW50KSB7XG4gICAgICAgIGlmICghdGhpcy5ldmVudENvdW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGxldCByZWJhc2VkSXRlbXMgPSBbXSwgc3RhcnQgPSBNYXRoLm1heCgwLCB0aGlzLml0ZW1zLmxlbmd0aCAtIHJlYmFzZWRDb3VudCk7XG4gICAgICAgIGxldCBtYXBwaW5nID0gcmViYXNlZFRyYW5zZm9ybS5tYXBwaW5nO1xuICAgICAgICBsZXQgbmV3VW50aWwgPSByZWJhc2VkVHJhbnNmb3JtLnN0ZXBzLmxlbmd0aDtcbiAgICAgICAgbGV0IGV2ZW50Q291bnQgPSB0aGlzLmV2ZW50Q291bnQ7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChpdGVtID0+IHsgaWYgKGl0ZW0uc2VsZWN0aW9uKVxuICAgICAgICAgICAgZXZlbnRDb3VudC0tOyB9LCBzdGFydCk7XG4gICAgICAgIGxldCBpUmViYXNlZCA9IHJlYmFzZWRDb3VudDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcuZ2V0TWlycm9yKC0taVJlYmFzZWQpO1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIG5ld1VudGlsID0gTWF0aC5taW4obmV3VW50aWwsIHBvcyk7XG4gICAgICAgICAgICBsZXQgbWFwID0gbWFwcGluZy5tYXBzW3Bvc107XG4gICAgICAgICAgICBpZiAoaXRlbS5zdGVwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSByZWJhc2VkVHJhbnNmb3JtLnN0ZXBzW3Bvc10uaW52ZXJ0KHJlYmFzZWRUcmFuc2Zvcm0uZG9jc1twb3NdKTtcbiAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gaXRlbS5zZWxlY3Rpb24gJiYgaXRlbS5zZWxlY3Rpb24ubWFwKG1hcHBpbmcuc2xpY2UoaVJlYmFzZWQgKyAxLCBwb3MpKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICBldmVudENvdW50Kys7XG4gICAgICAgICAgICAgICAgcmViYXNlZEl0ZW1zLnB1c2gobmV3IEl0ZW0obWFwLCBzdGVwLCBzZWxlY3Rpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlYmFzZWRJdGVtcy5wdXNoKG5ldyBJdGVtKG1hcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBzdGFydCk7XG4gICAgICAgIGxldCBuZXdNYXBzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSByZWJhc2VkQ291bnQ7IGkgPCBuZXdVbnRpbDsgaSsrKVxuICAgICAgICAgICAgbmV3TWFwcy5wdXNoKG5ldyBJdGVtKG1hcHBpbmcubWFwc1tpXSkpO1xuICAgICAgICBsZXQgaXRlbXMgPSB0aGlzLml0ZW1zLnNsaWNlKDAsIHN0YXJ0KS5hcHBlbmQobmV3TWFwcykuYXBwZW5kKHJlYmFzZWRJdGVtcyk7XG4gICAgICAgIGxldCBicmFuY2ggPSBuZXcgQnJhbmNoKGl0ZW1zLCBldmVudENvdW50KTtcbiAgICAgICAgaWYgKGJyYW5jaC5lbXB0eUl0ZW1Db3VudCgpID4gbWF4X2VtcHR5X2l0ZW1zKVxuICAgICAgICAgICAgYnJhbmNoID0gYnJhbmNoLmNvbXByZXNzKHRoaXMuaXRlbXMubGVuZ3RoIC0gcmViYXNlZEl0ZW1zLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBicmFuY2g7XG4gICAgfVxuICAgIGVtcHR5SXRlbUNvdW50KCkge1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7IGlmICghaXRlbS5zdGVwKVxuICAgICAgICAgICAgY291bnQrKzsgfSk7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgLy8gQ29tcHJlc3NpbmcgYSBicmFuY2ggbWVhbnMgcmV3cml0aW5nIGl0IHRvIHB1c2ggdGhlIGFpciAobWFwLW9ubHlcbiAgICAvLyBpdGVtcykgb3V0LiBEdXJpbmcgY29sbGFib3JhdGlvbiwgdGhlc2UgbmF0dXJhbGx5IGFjY3VtdWxhdGVcbiAgICAvLyBiZWNhdXNlIGVhY2ggcmVtb3RlIGNoYW5nZSBhZGRzIG9uZS4gVGhlIGB1cHRvYCBhcmd1bWVudCBpcyB1c2VkXG4gICAgLy8gdG8gZW5zdXJlIHRoYXQgb25seSB0aGUgaXRlbXMgYmVsb3cgYSBnaXZlbiBsZXZlbCBhcmUgY29tcHJlc3NlZCxcbiAgICAvLyBiZWNhdXNlIGByZWJhc2VkYCByZWxpZXMgb24gYSBjbGVhbiwgdW50b3VjaGVkIHNldCBvZiBpdGVtcyBpblxuICAgIC8vIG9yZGVyIHRvIGFzc29jaWF0ZSBvbGQgaXRlbXMgd2l0aCByZWJhc2VkIHN0ZXBzLlxuICAgIGNvbXByZXNzKHVwdG8gPSB0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICBsZXQgcmVtYXAgPSB0aGlzLnJlbWFwcGluZygwLCB1cHRvKSwgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICAgICAgICBsZXQgaXRlbXMgPSBbXSwgZXZlbnRzID0gMDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICBpZiAoaSA+PSB1cHRvKSB7XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50cysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5zdGVwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSBpdGVtLnN0ZXAubWFwKHJlbWFwLnNsaWNlKG1hcEZyb20pKSwgbWFwID0gc3RlcCAmJiBzdGVwLmdldE1hcCgpO1xuICAgICAgICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICAgICAgICBpZiAobWFwKVxuICAgICAgICAgICAgICAgICAgICByZW1hcC5hcHBlbmRNYXAobWFwLCBtYXBGcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0aW9uID0gaXRlbS5zZWxlY3Rpb24gJiYgaXRlbS5zZWxlY3Rpb24ubWFwKHJlbWFwLnNsaWNlKG1hcEZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50cysrO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV3SXRlbSA9IG5ldyBJdGVtKG1hcC5pbnZlcnQoKSwgc3RlcCwgc2VsZWN0aW9uKSwgbWVyZ2VkLCBsYXN0ID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lcmdlZCA9IGl0ZW1zLmxlbmd0aCAmJiBpdGVtc1tsYXN0XS5tZXJnZShuZXdJdGVtKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zW2xhc3RdID0gbWVyZ2VkO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKG5ld0l0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0ubWFwKSB7XG4gICAgICAgICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLml0ZW1zLmxlbmd0aCwgMCk7XG4gICAgICAgIHJldHVybiBuZXcgQnJhbmNoKFJvcGVTZXF1ZW5jZS5mcm9tKGl0ZW1zLnJldmVyc2UoKSksIGV2ZW50cyk7XG4gICAgfVxufVxuQnJhbmNoLmVtcHR5ID0gbmV3IEJyYW5jaChSb3BlU2VxdWVuY2UuZW1wdHksIDApO1xuZnVuY3Rpb24gY3V0T2ZmRXZlbnRzKGl0ZW1zLCBuKSB7XG4gICAgbGV0IGN1dFBvaW50O1xuICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgaWYgKGl0ZW0uc2VsZWN0aW9uICYmIChuLS0gPT0gMCkpIHtcbiAgICAgICAgICAgIGN1dFBvaW50ID0gaTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpdGVtcy5zbGljZShjdXRQb2ludCk7XG59XG5jbGFzcyBJdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvLyBUaGUgKGZvcndhcmQpIHN0ZXAgbWFwIGZvciB0aGlzIGl0ZW0uXG4gICAgbWFwLCBcbiAgICAvLyBUaGUgaW52ZXJ0ZWQgc3RlcFxuICAgIHN0ZXAsIFxuICAgIC8vIElmIHRoaXMgaXMgbm9uLW51bGwsIHRoaXMgaXRlbSBpcyB0aGUgc3RhcnQgb2YgYSBncm91cCwgYW5kXG4gICAgLy8gdGhpcyBzZWxlY3Rpb24gaXMgdGhlIHN0YXJ0aW5nIHNlbGVjdGlvbiBmb3IgdGhlIGdyb3VwICh0aGUgb25lXG4gICAgLy8gdGhhdCB3YXMgYWN0aXZlIGJlZm9yZSB0aGUgZmlyc3Qgc3RlcCB3YXMgYXBwbGllZClcbiAgICBzZWxlY3Rpb24sIFxuICAgIC8vIElmIHRoaXMgaXRlbSBpcyB0aGUgaW52ZXJzZSBvZiBhIHByZXZpb3VzIG1hcHBpbmcgb24gdGhlIHN0YWNrLFxuICAgIC8vIHRoaXMgcG9pbnRzIGF0IHRoZSBpbnZlcnNlJ3Mgb2Zmc2V0XG4gICAgbWlycm9yT2Zmc2V0KSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICB0aGlzLnN0ZXAgPSBzdGVwO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5taXJyb3JPZmZzZXQgPSBtaXJyb3JPZmZzZXQ7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLnN0ZXAgJiYgb3RoZXIuc3RlcCAmJiAhb3RoZXIuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgc3RlcCA9IG90aGVyLnN0ZXAubWVyZ2UodGhpcy5zdGVwKTtcbiAgICAgICAgICAgIGlmIChzdGVwKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSXRlbShzdGVwLmdldE1hcCgpLmludmVydCgpLCBzdGVwLCB0aGlzLnNlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBUaGUgdmFsdWUgb2YgdGhlIHN0YXRlIGZpZWxkIHRoYXQgdHJhY2tzIHVuZG8vcmVkbyBoaXN0b3J5IGZvciB0aGF0XG4vLyBzdGF0ZS4gV2lsbCBiZSBzdG9yZWQgaW4gdGhlIHBsdWdpbiBzdGF0ZSB3aGVuIHRoZSBoaXN0b3J5IHBsdWdpblxuLy8gaXMgYWN0aXZlLlxuY2xhc3MgSGlzdG9yeVN0YXRlIHtcbiAgICBjb25zdHJ1Y3Rvcihkb25lLCB1bmRvbmUsIHByZXZSYW5nZXMsIHByZXZUaW1lLCBwcmV2Q29tcG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5kb25lID0gZG9uZTtcbiAgICAgICAgdGhpcy51bmRvbmUgPSB1bmRvbmU7XG4gICAgICAgIHRoaXMucHJldlJhbmdlcyA9IHByZXZSYW5nZXM7XG4gICAgICAgIHRoaXMucHJldlRpbWUgPSBwcmV2VGltZTtcbiAgICAgICAgdGhpcy5wcmV2Q29tcG9zaXRpb24gPSBwcmV2Q29tcG9zaXRpb247XG4gICAgfVxufVxuY29uc3QgREVQVEhfT1ZFUkZMT1cgPSAyMDtcbi8vIFJlY29yZCBhIHRyYW5zZm9ybWF0aW9uIGluIHVuZG8gaGlzdG9yeS5cbmZ1bmN0aW9uIGFwcGx5VHJhbnNhY3Rpb24oaGlzdG9yeSwgc3RhdGUsIHRyLCBvcHRpb25zKSB7XG4gICAgbGV0IGhpc3RvcnlUciA9IHRyLmdldE1ldGEoaGlzdG9yeUtleSksIHJlYmFzZWQ7XG4gICAgaWYgKGhpc3RvcnlUcilcbiAgICAgICAgcmV0dXJuIGhpc3RvcnlUci5oaXN0b3J5U3RhdGU7XG4gICAgaWYgKHRyLmdldE1ldGEoY2xvc2VIaXN0b3J5S2V5KSlcbiAgICAgICAgaGlzdG9yeSA9IG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLCBoaXN0b3J5LnVuZG9uZSwgbnVsbCwgMCwgLTEpO1xuICAgIGxldCBhcHBlbmRlZCA9IHRyLmdldE1ldGEoXCJhcHBlbmRlZFRyYW5zYWN0aW9uXCIpO1xuICAgIGlmICh0ci5zdGVwcy5sZW5ndGggPT0gMCkge1xuICAgICAgICByZXR1cm4gaGlzdG9yeTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXBwZW5kZWQgJiYgYXBwZW5kZWQuZ2V0TWV0YShoaXN0b3J5S2V5KSkge1xuICAgICAgICBpZiAoYXBwZW5kZWQuZ2V0TWV0YShoaXN0b3J5S2V5KS5yZWRvKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZFRyYW5zZm9ybSh0ciwgdW5kZWZpbmVkLCBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLCBoaXN0b3J5LnVuZG9uZSwgcmFuZ2VzRm9yKHRyLm1hcHBpbmcubWFwc1t0ci5zdGVwcy5sZW5ndGggLSAxXSksIGhpc3RvcnkucHJldlRpbWUsIGhpc3RvcnkucHJldkNvbXBvc2l0aW9uKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLCBoaXN0b3J5LnVuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIHVuZGVmaW5lZCwgb3B0aW9ucywgbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpKSwgbnVsbCwgaGlzdG9yeS5wcmV2VGltZSwgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0ci5nZXRNZXRhKFwiYWRkVG9IaXN0b3J5XCIpICE9PSBmYWxzZSAmJiAhKGFwcGVuZGVkICYmIGFwcGVuZGVkLmdldE1ldGEoXCJhZGRUb0hpc3RvcnlcIikgPT09IGZhbHNlKSkge1xuICAgICAgICAvLyBHcm91cCB0cmFuc2Zvcm1zIHRoYXQgb2NjdXIgaW4gcXVpY2sgc3VjY2Vzc2lvbiBpbnRvIG9uZSBldmVudC5cbiAgICAgICAgbGV0IGNvbXBvc2l0aW9uID0gdHIuZ2V0TWV0YShcImNvbXBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgbmV3R3JvdXAgPSBoaXN0b3J5LnByZXZUaW1lID09IDAgfHxcbiAgICAgICAgICAgICghYXBwZW5kZWQgJiYgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24gIT0gY29tcG9zaXRpb24gJiZcbiAgICAgICAgICAgICAgICAoaGlzdG9yeS5wcmV2VGltZSA8ICh0ci50aW1lIHx8IDApIC0gb3B0aW9ucy5uZXdHcm91cERlbGF5IHx8ICFpc0FkamFjZW50VG8odHIsIGhpc3RvcnkucHJldlJhbmdlcykpKTtcbiAgICAgICAgbGV0IHByZXZSYW5nZXMgPSBhcHBlbmRlZCA/IG1hcFJhbmdlcyhoaXN0b3J5LnByZXZSYW5nZXMsIHRyLm1hcHBpbmcpIDogcmFuZ2VzRm9yKHRyLm1hcHBpbmcubWFwc1t0ci5zdGVwcy5sZW5ndGggLSAxXSk7XG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5hZGRUcmFuc2Zvcm0odHIsIG5ld0dyb3VwID8gc3RhdGUuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCkgOiB1bmRlZmluZWQsIG9wdGlvbnMsIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSksIEJyYW5jaC5lbXB0eSwgcHJldlJhbmdlcywgdHIudGltZSwgY29tcG9zaXRpb24gPT0gbnVsbCA/IGhpc3RvcnkucHJldkNvbXBvc2l0aW9uIDogY29tcG9zaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWJhc2VkID0gdHIuZ2V0TWV0YShcInJlYmFzZWRcIikpIHtcbiAgICAgICAgLy8gVXNlZCBieSB0aGUgY29sbGFiIG1vZHVsZSB0byB0ZWxsIHRoZSBoaXN0b3J5IHRoYXQgc29tZSBvZiBpdHNcbiAgICAgICAgLy8gY29udGVudCBoYXMgYmVlbiByZWJhc2VkLlxuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUucmViYXNlZCh0ciwgcmViYXNlZCksIGhpc3RvcnkudW5kb25lLnJlYmFzZWQodHIsIHJlYmFzZWQpLCBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSwgaGlzdG9yeS5wcmV2VGltZSwgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZE1hcHModHIubWFwcGluZy5tYXBzKSwgaGlzdG9yeS51bmRvbmUuYWRkTWFwcyh0ci5tYXBwaW5nLm1hcHMpLCBtYXBSYW5nZXMoaGlzdG9yeS5wcmV2UmFuZ2VzLCB0ci5tYXBwaW5nKSwgaGlzdG9yeS5wcmV2VGltZSwgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQWRqYWNlbnRUbyh0cmFuc2Zvcm0sIHByZXZSYW5nZXMpIHtcbiAgICBpZiAoIXByZXZSYW5nZXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIXRyYW5zZm9ybS5kb2NDaGFuZ2VkKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBsZXQgYWRqYWNlbnQgPSBmYWxzZTtcbiAgICB0cmFuc2Zvcm0ubWFwcGluZy5tYXBzWzBdLmZvckVhY2goKHN0YXJ0LCBlbmQpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2UmFuZ2VzLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKHN0YXJ0IDw9IHByZXZSYW5nZXNbaSArIDFdICYmIGVuZCA+PSBwcmV2UmFuZ2VzW2ldKVxuICAgICAgICAgICAgICAgIGFkamFjZW50ID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWRqYWNlbnQ7XG59XG5mdW5jdGlvbiByYW5nZXNGb3IobWFwKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIG1hcC5mb3JFYWNoKChfZnJvbSwgX3RvLCBmcm9tLCB0bykgPT4gcmVzdWx0LnB1c2goZnJvbSwgdG8pKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWFwUmFuZ2VzKHJhbmdlcywgbWFwcGluZykge1xuICAgIGlmICghcmFuZ2VzKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcChyYW5nZXNbaV0sIDEpLCB0byA9IG1hcHBpbmcubWFwKHJhbmdlc1tpICsgMV0sIC0xKTtcbiAgICAgICAgaWYgKGZyb20gPD0gdG8pXG4gICAgICAgICAgICByZXN1bHQucHVzaChmcm9tLCB0byk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBBcHBseSB0aGUgbGF0ZXN0IGV2ZW50IGZyb20gb25lIGJyYW5jaCB0byB0aGUgZG9jdW1lbnQgYW5kIHNoaWZ0IHRoZSBldmVudFxuLy8gb250byB0aGUgb3RoZXIgYnJhbmNoLlxuZnVuY3Rpb24gaGlzdFRyYW5zYWN0aW9uKGhpc3RvcnksIHN0YXRlLCBkaXNwYXRjaCwgcmVkbykge1xuICAgIGxldCBwcmVzZXJ2ZUl0ZW1zID0gbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpO1xuICAgIGxldCBoaXN0T3B0aW9ucyA9IGhpc3RvcnlLZXkuZ2V0KHN0YXRlKS5zcGVjLmNvbmZpZztcbiAgICBsZXQgcG9wID0gKHJlZG8gPyBoaXN0b3J5LnVuZG9uZSA6IGhpc3RvcnkuZG9uZSkucG9wRXZlbnQoc3RhdGUsIHByZXNlcnZlSXRlbXMpO1xuICAgIGlmICghcG9wKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHNlbGVjdGlvbiA9IHBvcC5zZWxlY3Rpb24ucmVzb2x2ZShwb3AudHJhbnNmb3JtLmRvYyk7XG4gICAgbGV0IGFkZGVkID0gKHJlZG8gPyBoaXN0b3J5LmRvbmUgOiBoaXN0b3J5LnVuZG9uZSkuYWRkVHJhbnNmb3JtKHBvcC50cmFuc2Zvcm0sIHN0YXRlLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpLCBoaXN0T3B0aW9ucywgcHJlc2VydmVJdGVtcyk7XG4gICAgbGV0IG5ld0hpc3QgPSBuZXcgSGlzdG9yeVN0YXRlKHJlZG8gPyBhZGRlZCA6IHBvcC5yZW1haW5pbmcsIHJlZG8gPyBwb3AucmVtYWluaW5nIDogYWRkZWQsIG51bGwsIDAsIC0xKTtcbiAgICBkaXNwYXRjaChwb3AudHJhbnNmb3JtLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pLnNldE1ldGEoaGlzdG9yeUtleSwgeyByZWRvLCBoaXN0b3J5U3RhdGU6IG5ld0hpc3QgfSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG59XG5sZXQgY2FjaGVkUHJlc2VydmVJdGVtcyA9IGZhbHNlLCBjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyA9IG51bGw7XG4vLyBDaGVjayB3aGV0aGVyIGFueSBwbHVnaW4gaW4gdGhlIGdpdmVuIHN0YXRlIGhhcyBhXG4vLyBgaGlzdG9yeVByZXNlcnZlSXRlbXNgIHByb3BlcnR5IGluIGl0cyBzcGVjLCBpbiB3aGljaCBjYXNlIHdlIG11c3Rcbi8vIHByZXNlcnZlIHN0ZXBzIGV4YWN0bHkgYXMgdGhleSBjYW1lIGluLCBzbyB0aGF0IHRoZXkgY2FuIGJlXG4vLyByZWJhc2VkLlxuZnVuY3Rpb24gbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpIHtcbiAgICBsZXQgcGx1Z2lucyA9IHN0YXRlLnBsdWdpbnM7XG4gICAgaWYgKGNhY2hlZFByZXNlcnZlSXRlbXNQbHVnaW5zICE9IHBsdWdpbnMpIHtcbiAgICAgICAgY2FjaGVkUHJlc2VydmVJdGVtcyA9IGZhbHNlO1xuICAgICAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zUGx1Z2lucyA9IHBsdWdpbnM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChwbHVnaW5zW2ldLnNwZWMuaGlzdG9yeVByZXNlcnZlSXRlbXMpIHtcbiAgICAgICAgICAgICAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZFByZXNlcnZlSXRlbXM7XG59XG4vKipcblNldCBhIGZsYWcgb24gdGhlIGdpdmVuIHRyYW5zYWN0aW9uIHRoYXQgd2lsbCBwcmV2ZW50IGZ1cnRoZXIgc3RlcHNcbmZyb20gYmVpbmcgYXBwZW5kZWQgdG8gYW4gZXhpc3RpbmcgaGlzdG9yeSBldmVudCAoc28gdGhhdCB0aGV5XG5yZXF1aXJlIGEgc2VwYXJhdGUgdW5kbyBjb21tYW5kIHRvIHVuZG8pLlxuKi9cbmZ1bmN0aW9uIGNsb3NlSGlzdG9yeSh0cikge1xuICAgIHJldHVybiB0ci5zZXRNZXRhKGNsb3NlSGlzdG9yeUtleSwgdHJ1ZSk7XG59XG5jb25zdCBoaXN0b3J5S2V5ID0gbmV3IFBsdWdpbktleShcImhpc3RvcnlcIik7XG5jb25zdCBjbG9zZUhpc3RvcnlLZXkgPSBuZXcgUGx1Z2luS2V5KFwiY2xvc2VIaXN0b3J5XCIpO1xuLyoqXG5SZXR1cm5zIGEgcGx1Z2luIHRoYXQgZW5hYmxlcyB0aGUgdW5kbyBoaXN0b3J5IGZvciBhbiBlZGl0b3IuIFRoZVxucGx1Z2luIHdpbGwgdHJhY2sgdW5kbyBhbmQgcmVkbyBzdGFja3MsIHdoaWNoIGNhbiBiZSB1c2VkIHdpdGggdGhlXG5bYHVuZG9gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jaGlzdG9yeS51bmRvKSBhbmQgW2ByZWRvYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2hpc3RvcnkucmVkbykgY29tbWFuZHMuXG5cbllvdSBjYW4gc2V0IGFuIGBcImFkZFRvSGlzdG9yeVwiYCBbbWV0YWRhdGFcbnByb3BlcnR5XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb24uc2V0TWV0YSkgb2YgYGZhbHNlYCBvbiBhIHRyYW5zYWN0aW9uXG50byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgcm9sbGVkIGJhY2sgYnkgdW5kby5cbiovXG5mdW5jdGlvbiBoaXN0b3J5KGNvbmZpZyA9IHt9KSB7XG4gICAgY29uZmlnID0geyBkZXB0aDogY29uZmlnLmRlcHRoIHx8IDEwMCxcbiAgICAgICAgbmV3R3JvdXBEZWxheTogY29uZmlnLm5ld0dyb3VwRGVsYXkgfHwgNTAwIH07XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICBrZXk6IGhpc3RvcnlLZXksXG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKEJyYW5jaC5lbXB0eSwgQnJhbmNoLmVtcHR5LCBudWxsLCAwLCAtMSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwbHkodHIsIGhpc3QsIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIHRyLCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb25maWcsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgICAgICBiZWZvcmVpbnB1dCh2aWV3LCBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnB1dFR5cGUgPSBlLmlucHV0VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbW1hbmQgPSBpbnB1dFR5cGUgPT0gXCJoaXN0b3J5VW5kb1wiID8gdW5kbyA6IGlucHV0VHlwZSA9PSBcImhpc3RvcnlSZWRvXCIgPyByZWRvIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb21tYW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kKHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG5BIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB1bmRvZXMgdGhlIGxhc3QgY2hhbmdlLCBpZiBhbnkuXG4qL1xuY29uc3QgdW5kbyA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgIGlmICghaGlzdCB8fCBoaXN0LmRvbmUuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBoaXN0VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIGRpc3BhdGNoLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5BIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCByZWRvZXMgdGhlIGxhc3QgdW5kb25lIGNoYW5nZSwgaWYgYW55LlxuKi9cbmNvbnN0IHJlZG8gPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICBpZiAoIWhpc3QgfHwgaGlzdC51bmRvbmUuZXZlbnRDb3VudCA9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBoaXN0VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIGRpc3BhdGNoLCB0cnVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcblRoZSBhbW91bnQgb2YgdW5kb2FibGUgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIHVuZG9EZXB0aChzdGF0ZSkge1xuICAgIGxldCBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIGhpc3QgPyBoaXN0LmRvbmUuZXZlbnRDb3VudCA6IDA7XG59XG4vKipcblRoZSBhbW91bnQgb2YgcmVkb2FibGUgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIGVkaXRvciBzdGF0ZS5cbiovXG5mdW5jdGlvbiByZWRvRGVwdGgoc3RhdGUpIHtcbiAgICBsZXQgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiBoaXN0ID8gaGlzdC51bmRvbmUuZXZlbnRDb3VudCA6IDA7XG59XG5cbmV4cG9ydCB7IGNsb3NlSGlzdG9yeSwgaGlzdG9yeSwgcmVkbywgcmVkb0RlcHRoLCB1bmRvLCB1bmRvRGVwdGggfTtcbiJdLCJuYW1lcyI6WyJSb3BlU2VxdWVuY2UiLCJNYXBwaW5nIiwiUGx1Z2luS2V5IiwiUGx1Z2luIiwibWF4X2VtcHR5X2l0ZW1zIiwiQnJhbmNoIiwiY29uc3RydWN0b3IiLCJpdGVtcyIsImV2ZW50Q291bnQiLCJwb3BFdmVudCIsInN0YXRlIiwicHJlc2VydmVJdGVtcyIsImVuZCIsImxlbmd0aCIsIm5leHQiLCJnZXQiLCJzZWxlY3Rpb24iLCJyZW1hcCIsIm1hcEZyb20iLCJyZW1hcHBpbmciLCJtYXBzIiwidHJhbnNmb3JtIiwidHIiLCJyZW1haW5pbmciLCJhZGRBZnRlciIsImFkZEJlZm9yZSIsImZvckVhY2giLCJpdGVtIiwiaSIsInN0ZXAiLCJwdXNoIiwiSXRlbSIsIm1hcCIsInNsaWNlIiwibWF5YmVTdGVwIiwiZG9jIiwibWFwcGluZyIsInVuZGVmaW5lZCIsImFwcGVuZE1hcCIsImFwcGVuZCIsInJldmVyc2UiLCJjb25jYXQiLCJhZGRUcmFuc2Zvcm0iLCJoaXN0T3B0aW9ucyIsIm5ld0l0ZW1zIiwib2xkSXRlbXMiLCJsYXN0SXRlbSIsInN0ZXBzIiwiaW52ZXJ0IiwiZG9jcyIsIm1lcmdlZCIsIm1lcmdlIiwicG9wIiwib3ZlcmZsb3ciLCJkZXB0aCIsIkRFUFRIX09WRVJGTE9XIiwiY3V0T2ZmRXZlbnRzIiwiZnJvbSIsInRvIiwibWlycm9yUG9zIiwibWlycm9yT2Zmc2V0IiwiYWRkTWFwcyIsImFycmF5IiwicmViYXNlZCIsInJlYmFzZWRUcmFuc2Zvcm0iLCJyZWJhc2VkQ291bnQiLCJyZWJhc2VkSXRlbXMiLCJzdGFydCIsIk1hdGgiLCJtYXgiLCJuZXdVbnRpbCIsImlSZWJhc2VkIiwicG9zIiwiZ2V0TWlycm9yIiwibWluIiwibmV3TWFwcyIsImJyYW5jaCIsImVtcHR5SXRlbUNvdW50IiwiY29tcHJlc3MiLCJjb3VudCIsInVwdG8iLCJldmVudHMiLCJnZXRNYXAiLCJuZXdJdGVtIiwibGFzdCIsImVtcHR5IiwibiIsImN1dFBvaW50Iiwib3RoZXIiLCJIaXN0b3J5U3RhdGUiLCJkb25lIiwidW5kb25lIiwicHJldlJhbmdlcyIsInByZXZUaW1lIiwicHJldkNvbXBvc2l0aW9uIiwiYXBwbHlUcmFuc2FjdGlvbiIsImhpc3RvcnkiLCJvcHRpb25zIiwiaGlzdG9yeVRyIiwiZ2V0TWV0YSIsImhpc3RvcnlLZXkiLCJoaXN0b3J5U3RhdGUiLCJjbG9zZUhpc3RvcnlLZXkiLCJhcHBlbmRlZCIsInJlZG8iLCJtdXN0UHJlc2VydmVJdGVtcyIsInJhbmdlc0ZvciIsImNvbXBvc2l0aW9uIiwibmV3R3JvdXAiLCJ0aW1lIiwibmV3R3JvdXBEZWxheSIsImlzQWRqYWNlbnRUbyIsIm1hcFJhbmdlcyIsImdldEJvb2ttYXJrIiwiZG9jQ2hhbmdlZCIsImFkamFjZW50IiwicmVzdWx0IiwiX2Zyb20iLCJfdG8iLCJyYW5nZXMiLCJoaXN0VHJhbnNhY3Rpb24iLCJkaXNwYXRjaCIsInNwZWMiLCJjb25maWciLCJyZXNvbHZlIiwiYWRkZWQiLCJuZXdIaXN0Iiwic2V0U2VsZWN0aW9uIiwic2V0TWV0YSIsInNjcm9sbEludG9WaWV3IiwiY2FjaGVkUHJlc2VydmVJdGVtcyIsImNhY2hlZFByZXNlcnZlSXRlbXNQbHVnaW5zIiwicGx1Z2lucyIsImhpc3RvcnlQcmVzZXJ2ZUl0ZW1zIiwiY2xvc2VIaXN0b3J5Iiwia2V5IiwiaW5pdCIsImFwcGx5IiwiaGlzdCIsInByb3BzIiwiaGFuZGxlRE9NRXZlbnRzIiwiYmVmb3JlaW5wdXQiLCJ2aWV3IiwiZSIsImlucHV0VHlwZSIsImNvbW1hbmQiLCJ1bmRvIiwicHJldmVudERlZmF1bHQiLCJnZXRTdGF0ZSIsInVuZG9EZXB0aCIsInJlZG9EZXB0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-history/dist/index.js\n");

/***/ })

};
;